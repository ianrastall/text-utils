<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Utilities</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0V2F0V7FWB"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-0V2F0V7FWB');
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-color: burlywood;
        }
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Roboto', sans-serif;
        }
        .card {
            background-color: #2a2a2a;
            border-color: #404040;
        }
        .form-control, .form-select {
            background-color: #1a1a1a;
            border-color: #404040;
            color: #e0e0e0;
        }
        .form-control:focus, .form-select:focus {
            background-color: #2a2a2a;
            border-color: var(--accent-color);
            color: #e0e0e0;
        }
        .btn-task {
            background-color: var(--accent-color);
            color: #000;
            border: none;
        }
        .btn-task:hover {
            background-color: var(--accent-color);
            opacity: 0.9;
            color: #000;
        }
        .btn-clear {
            background-color: #404040;
            color: #e0e0e0;
            border: none;
        }
        .btn-clear:hover {
            background-color: #505050;
            color: #e0e0e0;
        }
        .list-group-item {
            background-color: #2a2a2a;
            border-color: #404040;
        }
        .form-check-input:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        fieldset {
            border: 1px solid #404040;
            padding: 1rem;
            border-radius: 0.375rem;
        }
        legend {
            width: auto;
            padding: 0 0.5rem;
            margin-bottom: 0;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <div class="container-fluid my-4">
        <div class="row gx-3 gy-3">
            <main class="col-12">
                <div class="card bg-dark border-secondary">
                    <div class="card-body">
                        <h2 class="card-title mb-4 d-flex align-items-center">
                            <span class="material-icons me-3" aria-hidden="true" style="font-size: 36px;">schema</span>
                            <span>XML Sitemap Generator</span>
                        </h2>

                        <p class="text-white-50 mb-4">
                            Build a standards-compliant XML sitemap by crawling a live site starting from a single URL.
                        </p>

                        <form id="sitemapForm" class="post-content">
                            <fieldset class="mb-4">
                                <legend class="h5 mb-3">Crawl Settings</legend>
                                <p class="small text-white-50">
                                    Crawling runs entirely in your browser using fetch requests, so the target host must permit cross-origin access.
                                </p>
                                <div class="row g-3">
                                    <div class="col-md-8">
                                        <label for="startUrl" class="form-label fw-bold">Starting URL</label>
                                        <input type="url" class="form-control" id="startUrl" placeholder="https://example.com/">
                                    </div>
                                    <div class="col-md-4">
                                        <label for="maxDepth" class="form-label fw-bold">Max Depth</label>
                                        <input type="number" class="form-control" id="maxDepth" min="0" max="6" value="2">
                                        <div class="form-text">Depth of link following from the start page.</div>
                                    </div>
                                    <div class="col-md-4">
                                        <label for="maxPages" class="form-label fw-bold">Max Pages</label>
                                        <input type="number" class="form-control" id="maxPages" min="1" max="5000" value="200">
                                    </div>
                                    <div class="col-md-8">
                                        <label for="corsProxy" class="form-label fw-bold">CORS Proxy (optional)</label>
                                        <input type="text" class="form-control" id="corsProxy" placeholder="https://cors-anywhere.herokuapp.com/">
                                        <div class="form-text">
                                            Supply a proxy URL if your host blocks direct cross-origin requests.
                                            The proxy must support appending the target URL directly (e.g., proxy.com/target-url).
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label fw-bold">Link Filtering</label>
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="includeQuery">
                                            <label class="form-check-label" for="includeQuery">Keep query strings</label>
                                        </div>
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="stayOnHost" checked>
                                            <label class="form-check-label" for="stayOnHost">Stay on the starting host</label>
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label fw-bold">Robots.txt</label>
                                        <div class="form-text">
                                            This tool does not fetch robots.txt. Ensure you respect your site's crawl policies.
                                        </div>
                                    </div>
                                </div>
                            </fieldset>

                            <fieldset class="mb-4">
                                <legend class="h5 mb-3">Sitemap Options</legend>
                                <div class="row g-3">
                                    <div class="col-md-4">
                                        <label for="changefreq" class="form-label fw-bold">Default Change Frequency</label>
                                        <select id="changefreq" class="form-select">
                                            <option value="">(omit)</option>
                                            <option value="always">always</option>
                                            <option value="hourly">hourly</option>
                                            <option value="daily">daily</option>
                                            <option value="weekly">weekly</option>
                                            <option value="monthly">monthly</option>
                                            <option value="yearly">yearly</option>
                                            <option value="never">never</option>
                                        </select>
                                    </div>
                                    <div class="col-md-4">
                                        <label for="priorityInput" class="form-label fw-bold">Default Priority</label>
                                        <input type="number" class="form-control" id="priorityInput" min="0" max="1" step="0.1" placeholder="0.5">
                                        <div class="form-text">0.0 to 1.0. Leave blank to omit.</div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="form-check form-switch mt-4 pt-1">
                                            <input class="form-check-input" type="checkbox" id="collapseIndex" checked>
                                            <label class="form-check-label" for="collapseIndex">Collapse index.* to folder root</label>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="includeLastmod" checked>
                                            <label class="form-check-label fw-bold" for="includeLastmod">Include &lt;lastmod&gt;</label>
                                        </div>
                                        <div id="lastmodOptions" class="mt-2">
                                            <label for="lastmodSource" class="form-label">Last Modified Source</label>
                                            <select id="lastmodSource" class="form-select">
                                                <option value="current">Current timestamp (UTC)</option>
                                                <option value="http">HTTP Last-Modified header</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </fieldset>

                            <fieldset class="mb-4">
                                <legend class="h5 mb-3">Generate</legend>
                                <div class="d-flex flex-wrap gap-2">
                                    <button type="button" class="btn btn-task d-flex align-items-center" id="generateBtn">
                                        <span class="material-icons me-2" aria-hidden="true">play_arrow</span>
                                        Generate Sitemap
                                    </button>
                                    <button type="reset" class="btn btn-clear d-flex align-items-center" id="resetBtn">
                                        <span class="material-icons me-2" aria-hidden="true">restart_alt</span>
                                        Reset Form
                                    </button>
                                </div>
                            </fieldset>

                            <fieldset>
                                <legend class="h5 mb-3">Results</legend>
                                <div class="mb-3">
                                    <label for="outputXml" class="form-label fw-bold">Sitemap XML</label>
                                    <textarea id="outputXml" class="form-control font-monospace" rows="12" readonly placeholder="Your sitemap will appear here."></textarea>
                                </div>
                                <div class="d-flex flex-wrap gap-2 mb-3">
                                    <button type="button" class="btn btn-task btn-sm d-flex align-items-center" id="copyBtn" disabled>
                                        <span class="material-icons me-2" aria-hidden="true">content_copy</span>
                                        Copy XML
                                    </button>
                                    <button type="button" class="btn btn-task btn-sm d-flex align-items-center" id="downloadBtn" disabled>
                                        <span class="material-icons me-2" aria-hidden="true">download</span>
                                        Download sitemap.xml
                                    </button>
                                    <button type="button" class="btn btn-clear btn-sm d-flex align-items-center" id="clearBtn" disabled>
                                        <span class="material-icons me-2" aria-hidden="true">clear</span>
                                        Clear Output
                                    </button>
                                </div>
                                <div>
                                    <label class="form-label fw-bold">Status</label>
                                    <ul class="list-group list-group-flush bg-dark small" id="statusList" aria-live="polite" aria-label="Sitemap generation status" style="max-height: 260px; overflow-y: auto;"></ul>
                                </div>
                            </fieldset>
                        </form>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script>
        function formatAsW3CDate(value) {
            const date = value instanceof Date ? value : new Date(value);
            if (Number.isNaN(date.getTime())) {
                return null;
            }
            return date.toISOString();
        }

        function collapseIndexPath(pathname) {
            if (!pathname || pathname === '/') return '/';
            const lower = pathname.toLowerCase();
            const indexNames = ['index.html', 'index.htm', 'default.html', 'default.htm'];
            for (const name of indexNames) {
                if (lower === '/' + name) {
                    return '/';
                }
                if (lower.endsWith('/' + name)) {
                    return pathname.slice(0, -(name.length));
                }
            }
            return pathname;
        }

        function normalizeUrl(rawUrl, options = {}) {
            const includeQuery = options.includeQuery !== undefined ? options.includeQuery : true;
            const collapseIndex = Boolean(options.collapseIndex);
            try {
                const url = new URL(rawUrl);
                url.hash = '';
                if (!includeQuery) {
                    url.search = '';
                }
                if (collapseIndex) {
                    url.pathname = collapseIndexPath(url.pathname);
                }
                return url.href;
            } catch (error) {
                console.warn('Could not normalize URL:', rawUrl, error);
                return null;
            }
        }

        function buildRequestUrl(targetUrl, corsProxy) {
            if (!corsProxy || corsProxy.trim() === '') {
                return targetUrl;
            }

            const trimmedProxy = corsProxy.trim();
            
            // Validate the proxy URL
            try {
                new URL(trimmedProxy);
            } catch {
                console.warn('Invalid CORS proxy URL:', trimmedProxy);
                return targetUrl;
            }

            // Simple concatenation: proxy + target
            // Most CORS proxies work like: https://proxy.com/https://target.com
            if (trimmedProxy.endsWith('/')) {
                return trimmedProxy + targetUrl;
            } else {
                return trimmedProxy + '/' + targetUrl;
            }
        }

        function escapeXml(value) {
            return String(value).replace(/[<>&'"]/g, char => {
                switch (char) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '"': return '&quot;';
                    case '\'': return '&apos;';
                    default: return char;
                }
            });
        }

        function buildSitemapXml(entries) {
            const body = entries.map(entry => {
                const lines = [
                    '  <url>',
                    `    <loc>${escapeXml(entry.loc)}</loc>`
                ];
                if (entry.lastmod) {
                    lines.push(`    <lastmod>${escapeXml(entry.lastmod)}</lastmod>`);
                }
                if (entry.changefreq) {
                    lines.push(`    <changefreq>${entry.changefreq}</changefreq>`);
                }
                if (entry.priority) {
                    lines.push(`    <priority>${entry.priority}</priority>`);
                }
                lines.push('  </url>');
                return lines.join('\n');
            }).join('\n');

            return `<?xml version="1.0" encoding="UTF-8"?>\n<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n${body}\n</urlset>\n`;
        }

        function extractLinks(html, currentUrl, allowedOrigin, options) {
            const includeQuery = options.includeQuery;
            const collapseIndex = options.collapseIndex;
            const pageLinks = new Set();

            const addCandidate = (raw) => {
                if (!raw) return;
                const trimmed = raw.trim();
                if (!trimmed || trimmed.startsWith('#')) return;
                const blockedProtocols = ['mailto:', 'tel:', 'javascript:', 'data:'];
                const lowerTrimmed = trimmed.toLowerCase();
                if (blockedProtocols.some(prefix => lowerTrimmed.startsWith(prefix))) return;
                
                let resolved;
                try {
                    resolved = new URL(trimmed, currentUrl);
                } catch {
                    return;
                }
                
                if (resolved.origin !== allowedOrigin) return;
                
                const normalized = normalizeUrl(resolved.href, { includeQuery, collapseIndex });
                if (!normalized) return;
                
                pageLinks.add(normalized);
            };

            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                doc.querySelectorAll('a[href], area[href]').forEach(element => {
                    addCandidate(element.getAttribute('href'));
                });

                doc.querySelectorAll('link[rel="canonical"][href], link[rel="alternate"][href]').forEach(linkTag => {
                    addCandidate(linkTag.getAttribute('href'));
                });
            } catch (error) {
                console.warn('Failed to parse HTML for links:', error);
            }

            return Array.from(pageLinks);
        }

        function createEntry(loc, options, metadata = {}) {
            const normalized = normalizeUrl(loc, {
                includeQuery: options.includeQuery !== undefined ? options.includeQuery : true,
                collapseIndex: options.collapseIndex
            });
            const entry = {
                loc: normalized || loc
            };
            if (options.includeLastmod) {
                let lastmodValue = null;
                if (options.lastmodSource === 'http') {
                    if (metadata.httpLastModified) {
                        lastmodValue = formatAsW3CDate(metadata.httpLastModified);
                    }
                    if (!lastmodValue) {
                        lastmodValue = formatAsW3CDate(new Date());
                    }
                } else if (options.lastmodSource === 'current') {
                    lastmodValue = formatAsW3CDate(new Date());
                }
                if (lastmodValue) {
                    entry.lastmod = lastmodValue;
                }
            }
            if (options.changefreq) {
                entry.changefreq = options.changefreq;
            }
            if (options.priority !== null && options.priority !== undefined) {
                entry.priority = options.priority;
            }
            return entry;
        }

        async function crawlSite(startUrl, options, notify) {
            const entries = [];
            const entrySet = new Set();
            const visited = new Set();
            const enqueued = new Set();
            const queue = [];
            const corsProxy = (options.corsProxy || '').trim();

            const startingUrl = normalizeUrl(startUrl, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex });
            if (!startingUrl) {
                throw new Error('Unable to normalize the starting URL.');
            }

            const origin = new URL(startingUrl).origin;

            const enqueue = (targetUrl, depth) => {
                if (!targetUrl) return;
                
                let normalizedTarget;
                try {
                    normalizedTarget = new URL(targetUrl, startingUrl).href;
                } catch {
                    return;
                }
                
                const finalUrl = normalizeUrl(normalizedTarget, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex }) || normalizedTarget;
                
                if (options.stayOnHost && new URL(finalUrl).origin !== origin) return;
                if (visited.has(finalUrl) || enqueued.has(finalUrl)) return;
                if (depth > options.maxDepth) return;
                
                queue.push({ url: finalUrl, depth });
                enqueued.add(finalUrl);
            };

            enqueue(startingUrl, 0);

            while (queue.length > 0) {
                if (entries.length >= options.maxPages) {
                    notify(`Reached the page limit (${options.maxPages}).`, 'warning');
                    break;
                }

                const { url, depth } = queue.shift();
                if (visited.has(url)) continue;
                visited.add(url);

                const requestUrl = corsProxy ? buildRequestUrl(url, corsProxy) : url;
                notify(`Fetching: ${url}${corsProxy ? ' (via proxy)' : ''}`, 'info');

                let response;
                try {
                    response = await fetch(requestUrl, { 
                        mode: 'cors',
                        redirect: 'follow'
                    });
                } catch (error) {
                    const message = error?.message || 'Unknown error';
                    const suggestion = !corsProxy ? ' Try using a CORS proxy.' : '';
                    notify(`Failed to fetch ${url}: ${message}.${suggestion}`, 'warning');
                    continue;
                }

                // Only add pages that returned 200 OK
                if (response.status !== 200) {
                    notify(`Skipping ${url} (HTTP ${response.status})`, 'warning');
                    continue;
                }

                const contentType = (response.headers.get('content-type') || '').toLowerCase();
                const isHtml = contentType.includes('text/html') || contentType.includes('application/xhtml');

                if (!isHtml) {
                    notify(`Skipping ${url} (content-type: ${contentType})`, 'info');
                    continue;
                }

                let responseText = '';
                try {
                    responseText = await response.text();
                } catch {
                    notify(`Failed to read response from ${url}`, 'warning');
                    continue;
                }

                // Add to sitemap
                const pageKey = normalizeUrl(url, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex }) || url;
                if (!entrySet.has(pageKey)) {
                    const entry = createEntry(url, options, { httpLastModified: response.headers.get('last-modified') });
                    entries.push(entry);
                    entrySet.add(pageKey);
                    entrySet.add(entry.loc);
                    notify(`✓ Added: ${entry.loc}`, 'success');
                    
                    if (entries.length >= options.maxPages) {
                        notify(`Reached the page limit (${options.maxPages}).`, 'warning');
                        break;
                    }
                }

                // Extract and enqueue links if we haven't reached max depth
                if (depth < options.maxDepth && responseText) {
                    const pageLinks = extractLinks(responseText, url, origin, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex });
                    let enqueuedCount = 0;
                    for (const link of pageLinks) {
                        const beforeSize = enqueued.size;
                        enqueue(link, depth + 1);
                        if (enqueued.size > beforeSize) enqueuedCount++;
                    }
                    if (enqueuedCount > 0) {
                        notify(`  Found ${pageLinks.length} links, queued ${enqueuedCount} new URLs`, 'info');
                    }
                }
            }

            return entries
                .filter((entry, index, self) => self.findIndex(other => other.loc === entry.loc) === index)
                .sort((a, b) => a.loc.localeCompare(b.loc));
        }

        document.addEventListener('DOMContentLoaded', function () {
            const includeLastmod = document.getElementById('includeLastmod');
            const lastmodOptions = document.getElementById('lastmodOptions');
            const lastmodSource = document.getElementById('lastmodSource');
            const statusList = document.getElementById('statusList');
            const outputArea = document.getElementById('outputXml');
            const generateBtn = document.getElementById('generateBtn');
            const copyBtn = document.getElementById('copyBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resetBtn = document.getElementById('resetBtn');
            const sitemapForm = document.getElementById('sitemapForm');

            function clearStatus() {
                statusList.innerHTML = '';
            }

            function addStatus(message, tone = 'info') {
                const toneClassMap = {
                    success: 'text-success',
                    warning: 'text-warning',
                    danger: 'text-danger',
                    info: 'text-info'
                };
                const item = document.createElement('li');
                item.className = `list-group-item bg-dark border-secondary ${toneClassMap[tone] || 'text-white-50'}`;
                item.textContent = message;
                statusList.appendChild(item);
                statusList.scrollTop = statusList.scrollHeight;
            }

            function updateOutputActions() {
                const hasOutput = outputArea.value.trim().length > 0;
                copyBtn.disabled = !hasOutput;
                downloadBtn.disabled = !hasOutput;
                clearBtn.disabled = !hasOutput;
            }

            function toggleLastmodOptions() {
                lastmodOptions.classList.toggle('d-none', !includeLastmod.checked);
            }

            async function generateSitemap() {
                outputArea.value = '';
                updateOutputActions();
                clearStatus();

                const changefreq = document.getElementById('changefreq').value || null;
                const priorityRaw = document.getElementById('priorityInput').value.trim();
                const collapseIndex = document.getElementById('collapseIndex').checked;
                const corsProxyInput = (document.getElementById('corsProxy')?.value || '').trim();

                let priority = null;
                if (priorityRaw !== '') {
                    const parsed = Number(priorityRaw);
                    if (Number.isNaN(parsed) || parsed < 0 || parsed > 1) {
                        addStatus('Priority must be a number between 0.0 and 1.0.', 'danger');
                        return;
                    }
                    priority = (Math.round(parsed * 1000) / 1000).toString();
                }

                const options = {
                    includeLastmod: includeLastmod.checked,
                    lastmodSource: includeLastmod.checked ? lastmodSource.value : 'none',
                    changefreq,
                    priority,
                    collapseIndex,
                    corsProxy: corsProxyInput
                };

                generateBtn.disabled = true;
                addStatus('Starting sitemap generation...', 'info');

                try {
                    const startUrl = document.getElementById('startUrl').value.trim();
                    if (!startUrl) {
                        addStatus('Please enter a starting URL.', 'danger');
                        return;
                    }

                    let validatedStartUrl;
                    try {
                        validatedStartUrl = new URL(startUrl);
                    } catch {
                        addStatus('The starting URL is not valid.', 'danger');
                        return;
                    }

                    const maxDepth = parseInt(document.getElementById('maxDepth').value, 10);
                    const maxPages = parseInt(document.getElementById('maxPages').value, 10);

                    if (Number.isNaN(maxDepth) || maxDepth < 0) {
                        addStatus('Max depth must be zero or a positive integer.', 'danger');
                        return;
                    }
                    if (Number.isNaN(maxPages) || maxPages < 1) {
                        addStatus('Max pages must be at least 1.', 'danger');
                        return;
                    }

                    const includeQuery = document.getElementById('includeQuery').checked;
                    const stayOnHost = document.getElementById('stayOnHost').checked;

                    const entries = await crawlSite(validatedStartUrl.href, {
                        ...options,
                        includeQuery,
                        stayOnHost,
                        maxDepth,
                        maxPages
                    }, addStatus);

                    if (!entries.length) {
                        addStatus('No URLs were added to the sitemap. Check the status messages above.', 'warning');
                        return;
                    }

                    const xml = buildSitemapXml(entries);
                    outputArea.value = xml;
                    updateOutputActions();
                    addStatus(`✓ Sitemap generated successfully with ${entries.length} URL${entries.length === 1 ? '' : 's'}.`, 'success');
                } catch (error) {
                    console.error('Sitemap generation failed:', error);
                    addStatus(`Unexpected error: ${error.message}`, 'danger');
                } finally {
                    generateBtn.disabled = false;
                }
            }

            includeLastmod.addEventListener('change', () => {
                toggleLastmodOptions();
            });

            generateBtn.addEventListener('click', generateSitemap);

            copyBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(outputArea.value);
                    addStatus('Sitemap copied to clipboard.', 'success');
                } catch (error) {
                    addStatus('Copy failed. Your browser may not allow clipboard access.', 'warning');
                }
            });

            downloadBtn.addEventListener('click', () => {
                const blob = new Blob([outputArea.value], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'sitemap.xml';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                addStatus('sitemap.xml downloaded.', 'success');
            });

            clearBtn.addEventListener('click', () => {
                outputArea.value = '';
                updateOutputActions();
                addStatus('Output cleared.', 'info');
            });

            resetBtn.addEventListener('click', () => {
                setTimeout(() => {
                    sitemapForm.reset();
                    toggleLastmodOptions();
                    clearStatus();
                    outputArea.value = '';
                    updateOutputActions();
                    addStatus('Form reset.', 'info');
                }, 0);
            });

            toggleLastmodOptions();
            updateOutputActions();
        });
    </script>
</body>
</html>