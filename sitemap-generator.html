<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Utilities</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0V2F0V7FWB"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-0V2F0V7FWB');
    </script>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/custom.css">
</head>
<body>
    <div id="header-placeholder"></div>
    <div class="container-fluid my-4">
        <div class="row gx-3 gy-3">
            <main class="col-md-9">
                <div class="card bg-dark border-secondary">
                    <div class="card-body">
                        <h2 class="card-title mb-4 d-flex align-items-center" id="dynamic-title">
                            <span class="material-icons me-3" aria-hidden="true" style="font-size: 36px;">schema</span>
                            <span id="tool-name">XML Sitemap Generator</span>
                        </h2>

                        <p class="text-white-50 mb-4" id="tool-description">
                            Build a standards-compliant XML sitemap by crawling a live site starting from a single URL.
                        </p>

                        <form id="sitemapForm" class="post-content">
                            <fieldset class="mb-4">
                                <legend class="h5 mb-3">Crawl Settings</legend>
                                <p class="small text-white-50">
                                    Crawling runs entirely in your browser using fetch requests, so the target host must permit cross-origin access.
                                </p>
                                <div class="row g-3">
                                    <div class="col-md-8">
                                        <label for="startUrl" class="form-label fw-bold">Starting URL</label>
                                        <input type="url" class="form-control" id="startUrl" placeholder="https://example.com/">
                                    </div>
                                    <div class="col-md-4">
                                        <label for="maxDepth" class="form-label fw-bold">Max Depth</label>
                                        <input type="number" class="form-control" id="maxDepth" min="0" max="6" value="2">
                                        <div class="form-text">Depth of link following from the start page.</div>
                                    </div>
                                    <div class="col-md-4">
                                        <label for="maxPages" class="form-label fw-bold">Max Pages</label>
                                        <input type="number" class="form-control" id="maxPages" min="1" max="5000" value="200">
                                    </div>
                                    <div class="col-md-8">
                                        <label for="corsProxy" class="form-label fw-bold">CORS Proxy (optional)</label>
                                        <input type="text" class="form-control" id="corsProxy" placeholder="https://cors.isomorphic-git.org/">
                                        <div class="form-text">
                                            Supply a proxy URL if your host blocks direct cross-origin requests (commonly the case for GitHub-hosted sites).
                                            Leave blank to request pages directly. Use <code>{target}</code> in the proxy URL if it requires a placeholder for the encoded destination.
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label fw-bold">Link Filtering</label>
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="includeQuery">
                                            <label class="form-check-label" for="includeQuery">Keep query strings</label>
                                        </div>
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="stayOnHost" checked>
                                            <label class="form-check-label" for="stayOnHost">Stay on the starting host</label>
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label fw-bold">Robots.txt</label>
                                        <div class="form-text">
                                            This tool does not fetch robots.txt. Ensure you respect your site's crawl policies.
                                        </div>
                                    </div>
                                </div>
                            </fieldset>

                            <fieldset class="mb-4">
                                <legend class="h5 mb-3">Sitemap Options</legend>
                                <div class="row g-3">
                                    <div class="col-md-4">
                                        <label for="changefreq" class="form-label fw-bold">Default Change Frequency</label>
                                        <select id="changefreq" class="form-select">
                                            <option value="">(omit)</option>
                                            <option value="always">always</option>
                                            <option value="hourly">hourly</option>
                                            <option value="daily">daily</option>
                                            <option value="weekly">weekly</option>
                                            <option value="monthly">monthly</option>
                                            <option value="yearly">yearly</option>
                                            <option value="never">never</option>
                                        </select>
                                    </div>
                                    <div class="col-md-4">
                                        <label for="priorityInput" class="form-label fw-bold">Default Priority</label>
                                        <input type="number" class="form-control" id="priorityInput" min="0" max="1" step="0.1" placeholder="0.5">
                                        <div class="form-text">0.0 to 1.0. Leave blank to omit.</div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="form-check form-switch mt-4 pt-1">
                                            <input class="form-check-input" type="checkbox" id="collapseIndex" checked>
                                            <label class="form-check-label" for="collapseIndex">Collapse index.* to folder root</label>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="includeLastmod" checked>
                                            <label class="form-check-label fw-bold" for="includeLastmod">Include &lt;lastmod&gt;</label>
                                        </div>
                                        <div id="lastmodOptions" class="mt-2">
                                            <label for="lastmodSource" class="form-label">Last Modified Source</label>
                                            <select id="lastmodSource" class="form-select">
                                                <option value="current">Current timestamp (UTC)</option>
                                                <option value="http">HTTP Last-Modified header</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </fieldset>

                            <fieldset class="mb-4">
                                <legend class="h5 mb-3">Generate</legend>
                                <div class="d-flex flex-wrap gap-2">
                                    <button type="button" class="btn btn-task d-flex align-items-center" id="generateBtn">
                                        <span class="material-icons me-2" aria-hidden="true">play_arrow</span>
                                        Generate Sitemap
                                    </button>
                                    <button type="reset" class="btn btn-clear d-flex align-items-center" id="resetBtn">
                                        <span class="material-icons me-2" aria-hidden="true">restart_alt</span>
                                        Reset Form
                                    </button>
                                </div>
                            </fieldset>

                            <fieldset>
                                <legend class="h5 mb-3">Results</legend>
                                <div class="mb-3">
                                    <label for="outputXml" class="form-label fw-bold">Sitemap XML</label>
                                    <textarea id="outputXml" class="form-control font-monospace" rows="12" readonly placeholder="Your sitemap will appear here."></textarea>
                                </div>
                                <div class="d-flex flex-wrap gap-2 mb-3">
                                    <button type="button" class="btn btn-task btn-sm d-flex align-items-center" id="copyBtn" disabled>
                                        <span class="material-icons me-2" aria-hidden="true">content_copy</span>
                                        Copy XML
                                    </button>
                                    <button type="button" class="btn btn-task btn-sm d-flex align-items-center" id="downloadBtn" disabled>
                                        <span class="material-icons me-2" aria-hidden="true">download</span>
                                        Download sitemap.xml
                                    </button>
                                    <button type="button" class="btn btn-clear btn-sm d-flex align-items-center" id="clearBtn" disabled>
                                        <span class="material-icons me-2" aria-hidden="true">clear</span>
                                        Clear Output
                                    </button>
                                </div>
                                <div>
                                    <label class="form-label fw-bold">Status</label>
                                    <ul class="list-group list-group-flush bg-dark small" id="statusList" aria-live="polite" aria-label="Sitemap generation status" style="max-height: 260px; overflow-y: auto;"></ul>
                                </div>
                            </fieldset>
                        </form>
                    </div>
                </div>
            </main>
            <aside class="col-md-3">
                <div class="card bg-dark border-secondary">
                    <div class="card-body p-0">
                        <nav class="sidebar nav flex-column" id="dynamic-sidebar"></nav>
                    </div>
                </div>
            </aside>
        </div>
    </div>
    <div id="footer-placeholder"></div>
    
    <script src="js/bootstrap.bundle.min.js"></script>
    <script src="js/component-loader.js"></script>

    <script>
        function initThemeSwitcher() {
            const themes = [
                'burlywood', 'cadetblue', 'cornflowerblue', 'dodgerblue', 'lightcoral', 'lightgreen', 'plum', 'thistle', 'tomato', 'violet',
                'goldenyellow', 'mutedcoral', 'softpink', 'lightcyan', 'lightgray', 'neongreen', 'brightyellow'
            ];
            const themeDropdown = document.getElementById('accentColorDropdownMenu');
            const htmlElement = document.documentElement;

            function applyTheme(theme) {
                htmlElement.className = '';
                htmlElement.classList.add('theme-' + theme);
                localStorage.setItem('accentTheme', theme);
            }

            if (themeDropdown) {
                themes.forEach(theme => {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.className = 'dropdown-item';
                    button.type = 'button';
                    button.textContent = theme;
                    button.onclick = () => applyTheme(theme);
                    li.appendChild(button);
                    themeDropdown.appendChild(li);
                });
            }

            const savedTheme = localStorage.getItem('accentTheme') || 'burlywood';
            applyTheme(savedTheme);
        }

        async function initPageMetadata() {
            const currentSlug = 'sitemap-generator';

            try {
                const response = await fetch('config/tools.json');
                if (!response.ok) throw new Error('Failed to load tools.json');
                const tools = await response.json();

                const currentTool = tools.find(tool => tool.slug === currentSlug) || {};

                document.getElementById('tool-name').textContent = currentTool.name || 'XML Sitemap Generator';
                document.getElementById('tool-description').textContent = currentTool.description || 'Build a standards-compliant XML sitemap by crawling a live site starting from a single URL.';

                const iconEl = document.getElementById('tool-icon');
                if (currentTool.icon) {
                    if (currentTool.icon.endsWith('.svg') || currentTool.icon.endsWith('.png')) {
                        iconEl.textContent = '';
                        iconEl.outerHTML = `<img src="${currentTool.icon}" alt="" style="height: 36px; margin-right: 15px;" id="tool-icon" aria-hidden="true" />`;
                    } else {
                        iconEl.outerHTML = `<span class="material-icons me-3" style="font-size: 36px;" aria-hidden="true">${currentTool.icon}</span>`;
                    }
                }

                const sidebarHtml = tools
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .map(tool => {
                        const isActive = tool.slug === currentSlug;
                        const activeClass = isActive ? ' active' : '';
                        const iconHtml = tool.icon ?
                            (tool.icon.endsWith('.svg') || tool.icon.endsWith('.png') ?
                                `<img src="${tool.icon}" alt="" class="icon me-2" aria-hidden="true" />` :
                                `<span class="material-icons me-2" aria-hidden="true">${tool.icon}</span>`) :
                            `<span class="me-2" style="width: 24px;"></span>`;

                        return `
                            <a class="nav-link d-flex align-items-center${activeClass}" href="${tool.slug}.html">
                                ${iconHtml}
                                <span>${tool.name}</span>
                            </a>
                        `;
                    }).join('');

                document.getElementById('dynamic-sidebar').innerHTML = sidebarHtml;
            } catch (error) {
                console.error('Error loading metadata:', error);
            }
        }

        function formatAsW3CDate(value) {
            const date = value instanceof Date ? value : new Date(value);
            if (Number.isNaN(date.getTime())) {
                return null;
            }
            return date.toISOString();
        }

        function collapseIndexPath(pathname) {
            if (!pathname) return '/';
            const lower = pathname.toLowerCase();
            const indexNames = ['index.html', 'index.htm', 'default.html', 'default.htm'];
            for (const name of indexNames) {
                if (lower === name) {
                    return '/';
                }
                if (lower.endsWith('/' + name)) {
                    const trimmed = pathname.slice(0, -name.length);
                    return trimmed === '' ? '/' : trimmed;
                }
            }
            return pathname;
        }

        function normalizeUrl(rawUrl, options = {}) {
            const includeQuery = options.includeQuery !== undefined ? options.includeQuery : true;
            const collapseIndex = Boolean(options.collapseIndex);
            try {
                const url = new URL(rawUrl);
                url.hash = '';
                if (!includeQuery) {
                    url.search = '';
                }
                if (collapseIndex) {
                    url.pathname = collapseIndexPath(url.pathname);
                }
                return url.href;
            } catch (error) {
                console.warn('Could not normalize URL:', rawUrl, error);
                return null;
            }
        }

        function buildRequestUrl(targetUrl, corsProxy) {
            if (!corsProxy) {
                return targetUrl;
            }

            const trimmedProxy = corsProxy.trim();
            if (trimmedProxy === '') {
                return targetUrl;
            }

            if (trimmedProxy.includes('{target}')) {
                return trimmedProxy.replace(/\{target\}/g, encodeURIComponent(targetUrl));
            }

            const lastChar = trimmedProxy.slice(-1);
            if (lastChar === '?' || lastChar === '&' || lastChar === '=') {
                return `${trimmedProxy}${encodeURIComponent(targetUrl)}`;
            }

            const joiner = trimmedProxy.endsWith('/') ? '' : '/';
            return `${trimmedProxy}${joiner}${targetUrl}`;
        }

        function escapeXml(value) {
            return String(value).replace(/[<>&'"]/g, char => {
                switch (char) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '"': return '&quot;';
                    case '\'': return '&apos;';
                    default: return char;
                }
            });
        }

        function buildSitemapXml(entries) {
            const body = entries.map(entry => {
                const lines = [
                    '  <url>',
                    `    <loc>${escapeXml(entry.loc)}</loc>`
                ];
                if (entry.lastmod) {
                    lines.push(`    <lastmod>${escapeXml(entry.lastmod)}</lastmod>`);
                }
                if (entry.changefreq) {
                    lines.push(`    <changefreq>${entry.changefreq}</changefreq>`);
                }
                if (entry.priority) {
                    lines.push(`    <priority>${entry.priority}</priority>`);
                }
                lines.push('  </url>');
                return lines.join('\n');
            }).join('\n');

            return `<?xml version="1.0" encoding="UTF-8"?>\n<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n${body}\n</urlset>\n`;
        }

        function extractLinks(html, currentUrl, allowedOrigin, options) {
            const includeQuery = options.includeQuery;
            const collapseIndex = options.collapseIndex;
            const pageLinks = new Set();
            const resourceLinks = new Set();

            const addCandidate = (raw, type = 'page') => {
                if (!raw) return;
                const trimmed = raw.trim();
                if (!trimmed || trimmed.startsWith('#')) return;
                const blockedProtocols = ['mailto:', 'tel:', 'javascript:', 'data:'];
                const lowerTrimmed = trimmed.toLowerCase();
                if (blockedProtocols.some(prefix => lowerTrimmed.startsWith(prefix))) return;
                let resolved;
                try {
                    resolved = new URL(trimmed, currentUrl);
                } catch {
                    return;
                }
                if (resolved.origin !== allowedOrigin) return;
                const normalized = normalizeUrl(resolved.href, { includeQuery, collapseIndex });
                if (!normalized) return;
                if (type === 'resource') {
                    resourceLinks.add(normalized);
                } else {
                    pageLinks.add(normalized);
                }
            };

            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                doc.querySelectorAll('a[href], area[href]').forEach(element => {
                    addCandidate(element.getAttribute('href'), 'page');
                });

                doc.querySelectorAll('link[rel="canonical"][href], link[rel="alternate"][href]').forEach(linkTag => {
                    addCandidate(linkTag.getAttribute('href'), 'page');
                });
            } catch (error) {
                console.warn('Failed to parse HTML for links:', error);
            }

            const resourcePattern = /["']([^"'<>]+?\.(?:json|jsonp|xml|txt|csv|ya?ml))(?:\?[^"']*)?["']/gi;
            let match;
            while ((match = resourcePattern.exec(html)) !== null) {
                addCandidate(match[1], 'resource');
            }

            return {
                pageLinks: Array.from(pageLinks),
                resourceLinks: Array.from(resourceLinks)
            };
        }

        function extractUrlsFromJson(data, currentUrl, allowedOrigin, options) {
            const pageLinks = new Set();
            const resourceLinks = new Set();
            const baseUrl = new URL(currentUrl);

            const resourceExtensions = ['.json', '.xml', '.yaml', '.yml', '.txt', '.csv'];
            const pageExtensions = ['.html', '.htm', '.php', '.asp', '.aspx', '.jsp'];

            const pushCandidate = (value, keyHint = '') => {
                if (!value) return;
                let candidate = value.trim();
                if (!candidate) return;

                const lowerHint = keyHint.toLowerCase();
                if (lowerHint === 'slug' || lowerHint.endsWith('slug')) {
                    candidate = candidate.replace(/^\//, '');
                    if (!candidate.match(/\.(html?|php|asp(x)?|jsp)$/i)) {
                        candidate = `${candidate}.html`;
                    }
                }

                let type = 'page';
                const lowerCandidate = candidate.toLowerCase();
                if (resourceExtensions.some(ext => lowerCandidate.endsWith(ext))) {
                    type = 'resource';
                } else if (pageExtensions.some(ext => lowerCandidate.endsWith(ext))) {
                    type = 'page';
                } else if (lowerCandidate.endsWith('/')) {
                    type = 'page';
                } else if (lowerCandidate.includes('.json')) {
                    type = 'resource';
                }

                let resolved;
                try {
                    resolved = new URL(candidate, baseUrl);
                } catch {
                    return;
                }

                if (options.stayOnHost && resolved.origin !== allowedOrigin) {
                    return;
                }

                const normalized = normalizeUrl(resolved.href, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex });
                if (!normalized) return;

                if (type === 'resource') {
                    resourceLinks.add(normalized);
                } else {
                    pageLinks.add(normalized);
                }
            };

            const walk = (node, keyHint = '') => {
                if (typeof node === 'string') {
                    const trimmed = node.trim();
                    if (!trimmed) return;
                    const lower = trimmed.toLowerCase();
                    if (
                        lower.startsWith('http://') ||
                        lower.startsWith('https://') ||
                        lower.startsWith('//') ||
                        lower.startsWith('/') ||
                        lower.includes('.html') ||
                        lower.includes('.htm') ||
                        lower.includes('.php') ||
                        lower.includes('.asp') ||
                        lower.includes('.jsp') ||
                        lower.endsWith('.json')
                    ) {
                        pushCandidate(trimmed, keyHint);
                    } else if (keyHint.toLowerCase().includes('slug')) {
                        pushCandidate(trimmed, keyHint);
                    }
                } else if (Array.isArray(node)) {
                    node.forEach(item => walk(item, keyHint));
                } else if (node && typeof node === 'object') {
                    Object.entries(node).forEach(([key, value]) => walk(value, key));
                }
            };

            walk(data);

            return {
                pageLinks: Array.from(pageLinks),
                resourceLinks: Array.from(resourceLinks)
            };
        }

        function createEntry(loc, options, metadata = {}) {
            const normalized = normalizeUrl(loc, {
                includeQuery: options.includeQuery !== undefined ? options.includeQuery : true,
                collapseIndex: options.collapseIndex
            });
            const entry = {
                loc: normalized || loc
            };
            if (options.includeLastmod) {
                let lastmodValue = null;
                if (options.lastmodSource === 'http') {
                    if (metadata.httpLastModified) {
                        lastmodValue = formatAsW3CDate(metadata.httpLastModified);
                    }
                    if (!lastmodValue) {
                        lastmodValue = formatAsW3CDate(new Date());
                    }
                } else if (options.lastmodSource === 'current') {
                    lastmodValue = formatAsW3CDate(new Date());
                }
                if (lastmodValue) {
                    entry.lastmod = lastmodValue;
                }
            }
            if (options.changefreq) {
                entry.changefreq = options.changefreq;
            }
            if (options.priority !== null && options.priority !== undefined) {
                entry.priority = options.priority;
            }
            return entry;
        }

        async function crawlSite(startUrl, options, notify) {
            const entries = [];
            const entrySet = new Set();
            const visited = new Set();
            const enqueued = new Set();
            const queue = [];
            const corsProxy = (options.corsProxy || '').trim();

            const startingUrl = normalizeUrl(startUrl, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex });
            if (!startingUrl) {
                throw new Error('Unable to normalize the starting URL.');
            }

            const origin = new URL(startingUrl).origin;

            const enqueue = (targetUrl, depth, type) => {
                if (!targetUrl && targetUrl !== '') return;
                let normalizedTarget;
                try {
                    normalizedTarget = new URL(targetUrl, startingUrl).href;
                } catch {
                    return;
                }
                const finalUrl = normalizeUrl(normalizedTarget, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex }) || normalizedTarget;
                if (options.stayOnHost && new URL(finalUrl).origin !== origin) return;
                if (visited.has(finalUrl) || enqueued.has(finalUrl)) return;
                if (type === 'page' && depth > options.maxDepth) return;
                queue.push({ url: finalUrl, depth, type });
                enqueued.add(finalUrl);
            };

            enqueue(startingUrl, 0, 'page');

            while (queue.length > 0) {
                if (entries.length >= options.maxPages) {
                    notify(`Reached the page limit (${options.maxPages}).`, 'warning');
                    break;
                }

                const { url, depth, type } = queue.shift();
                if (visited.has(url)) continue;
                visited.add(url);

                const requestUrl = corsProxy ? buildRequestUrl(url, corsProxy) : url;
                const fetchLabel = corsProxy ? `${url} (via proxy)` : url;
                notify(`Fetching ${fetchLabel}`, 'info');

                let response;
                try {
                    response = await fetch(requestUrl, { mode: 'cors' });
                } catch (error) {
                    const message = error && error.message ? error.message : 'Unknown error';
                    const suggestion = corsProxy ? '' : ' Provide a CORS proxy if the host blocks cross-origin requests.';
                    notify(`Failed to fetch ${url}: ${message}.${suggestion}`, 'warning');
                    continue;
                }

                if (!response.ok) {
                    notify(`Skipping ${url} (HTTP ${response.status}).`, 'warning');
                    continue;
                }

                const contentType = (response.headers.get('content-type') || '').toLowerCase();
                const isHtml = contentType.includes('text/html') || contentType.includes('application/xhtml');
                const isXml = contentType.includes('xml');
                const isJson = contentType.includes('json') || url.toLowerCase().endsWith('.json');

                let responseText = '';
                if (isHtml || isXml || isJson) {
                    try {
                        responseText = await response.text();
                    } catch {
                        responseText = '';
                    }
                } else {
                    await response.text().catch(() => null);
                }

                const pageKey = normalizeUrl(url, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex }) || url;
                if (type === 'page' && !entrySet.has(pageKey)) {
                    const entry = createEntry(url, options, { httpLastModified: response.headers.get('last-modified') });
                    entries.push(entry);
                    entrySet.add(pageKey);
                    entrySet.add(entry.loc);
                    notify(`Added ${entry.loc}`, 'success');
                    if (entries.length >= options.maxPages) {
                        notify(`Reached the page limit (${options.maxPages}).`, 'warning');
                        break;
                    }
                }

                if ((isHtml || isXml) && responseText && depth < options.maxDepth) {
                    const { pageLinks, resourceLinks } = extractLinks(responseText, url, origin, { includeQuery: options.includeQuery, collapseIndex: options.collapseIndex });
                    for (const link of pageLinks) {
                        enqueue(link, depth + 1, 'page');
                    }
                    for (const resource of resourceLinks) {
                        enqueue(resource, depth, 'resource');
                    }
                    if (pageLinks.length || resourceLinks.length) {
                        notify(`Discovered ${pageLinks.length} page link(s) and ${resourceLinks.length} resource link(s) in ${url}.`, 'info');
                    }
                }

                if (isJson && responseText) {
                    try {
                        const jsonData = JSON.parse(responseText);
                        const { pageLinks, resourceLinks } = extractUrlsFromJson(jsonData, url, origin, options);
                        pageLinks.forEach(link => enqueue(link, depth + 1, 'page'));
                        resourceLinks.forEach(resource => enqueue(resource, depth + 1, 'resource'));
                        if (pageLinks.length || resourceLinks.length) {
                            notify(`Parsed JSON at ${url} and found ${pageLinks.length} page link(s) and ${resourceLinks.length} resource link(s).`, 'info');
                        }
                    } catch (error) {
                        notify(`Failed to parse JSON from ${url}: ${error.message}`, 'warning');
                    }
                }
            }

            return entries
                .filter((entry, index, self) => self.findIndex(other => other.loc === entry.loc) === index)
                .sort((a, b) => a.loc.localeCompare(b.loc));
        }

        document.addEventListener('DOMContentLoaded', async function () {
            await ComponentLoader.loadAll();
            initThemeSwitcher();
            await initPageMetadata();

            const includeLastmod = document.getElementById('includeLastmod');
            const lastmodOptions = document.getElementById('lastmodOptions');
            const lastmodSource = document.getElementById('lastmodSource');
            const statusList = document.getElementById('statusList');
            const outputArea = document.getElementById('outputXml');
            const generateBtn = document.getElementById('generateBtn');
            const copyBtn = document.getElementById('copyBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resetBtn = document.getElementById('resetBtn');
            const sitemapForm = document.getElementById('sitemapForm');

            function clearStatus() {
                statusList.innerHTML = '';
            }

            function addStatus(message, tone = 'info') {
                const toneClassMap = {
                    success: 'text-success',
                    warning: 'text-warning',
                    danger: 'text-danger',
                    info: 'text-info'
                };
                const item = document.createElement('li');
                item.className = `list-group-item bg-dark border-secondary ${toneClassMap[tone] || 'text-white-50'}`;
                item.textContent = message;
                statusList.appendChild(item);
                statusList.scrollTop = statusList.scrollHeight;
            }

            function updateOutputActions() {
                const hasOutput = outputArea.value.trim().length > 0;
                copyBtn.disabled = !hasOutput;
                downloadBtn.disabled = !hasOutput;
                clearBtn.disabled = !hasOutput;
            }

            function toggleLastmodOptions() {
                lastmodOptions.classList.toggle('d-none', !includeLastmod.checked);
            }

            async function generateSitemap() {
                outputArea.value = '';
                updateOutputActions();
                clearStatus();

                const changefreq = document.getElementById('changefreq').value || null;
                const priorityRaw = document.getElementById('priorityInput').value.trim();
                const collapseIndex = document.getElementById('collapseIndex').checked;
                const corsProxyInput = (document.getElementById('corsProxy')?.value || '').trim();

                let priority = null;
                if (priorityRaw !== '') {
                    const parsed = Number(priorityRaw);
                    if (Number.isNaN(parsed) || parsed < 0 || parsed > 1) {
                        addStatus('Priority must be a number between 0.0 and 1.0.', 'danger');
                        return;
                    }
                    priority = (Math.round(parsed * 1000) / 1000).toString();
                }

                const options = {
                    includeLastmod: includeLastmod.checked,
                    lastmodSource: includeLastmod.checked ? lastmodSource.value : 'none',
                    changefreq,
                    priority,
                    collapseIndex,
                    corsProxy: corsProxyInput
                };

                generateBtn.disabled = true;
                addStatus('Starting sitemap generation...', 'info');

                try {
                    const startUrl = document.getElementById('startUrl').value.trim();
                    if (!startUrl) {
                        addStatus('Please enter a starting URL.', 'danger');
                        return;
                    }

                    let validatedStartUrl;
                    try {
                        validatedStartUrl = new URL(startUrl);
                    } catch {
                        addStatus('The starting URL is not valid.', 'danger');
                        return;
                    }

                    const maxDepth = parseInt(document.getElementById('maxDepth').value, 10);
                    const maxPages = parseInt(document.getElementById('maxPages').value, 10);

                    if (Number.isNaN(maxDepth) || maxDepth < 0) {
                        addStatus('Max depth must be zero or a positive integer.', 'danger');
                        return;
                    }
                    if (Number.isNaN(maxPages) || maxPages < 1) {
                        addStatus('Max pages must be at least 1.', 'danger');
                        return;
                    }

                    const includeQuery = document.getElementById('includeQuery').checked;
                    const stayOnHost = document.getElementById('stayOnHost').checked;

                    const entries = await crawlSite(validatedStartUrl.href, {
                        ...options,
                        includeQuery,
                        stayOnHost,
                        maxDepth,
                        maxPages
                    }, addStatus);

                    if (!entries.length) {
                        addStatus('No URLs were added to the sitemap. Adjust your settings and try again.', 'warning');
                        return;
                    }

                    const xml = buildSitemapXml(entries);
                    outputArea.value = xml;
                    updateOutputActions();
                    addStatus(`Sitemap generated with ${entries.length} URL${entries.length === 1 ? '' : 's'}.`, 'success');
                } catch (error) {
                    console.error('Sitemap generation failed:', error);
                    addStatus(`Unexpected error: ${error.message}`, 'danger');
                } finally {
                    generateBtn.disabled = false;
                }
            }

            includeLastmod.addEventListener('change', () => {
                toggleLastmodOptions();
            });

            generateBtn.addEventListener('click', generateSitemap);

            copyBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(outputArea.value);
                    addStatus('Sitemap copied to clipboard.', 'success');
                } catch (error) {
                    addStatus('Copy failed. Your browser may not allow clipboard access.', 'warning');
                }
            });

            downloadBtn.addEventListener('click', () => {
                const blob = new Blob([outputArea.value], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'sitemap.xml';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                addStatus('sitemap.xml downloaded.', 'success');
            });

            clearBtn.addEventListener('click', () => {
                outputArea.value = '';
                updateOutputActions();
                addStatus('Output cleared.', 'info');
            });

            resetBtn.addEventListener('click', () => {
                setTimeout(() => {
                    sitemapForm.reset();
                    toggleLastmodOptions();
                    clearStatus();
                    outputArea.value = '';
                    updateOutputActions();
                    addStatus('Form reset.', 'info');
                }, 0);
            });

            toggleLastmodOptions();
            updateOutputActions();
        });
    </script>
</body>
</html>
