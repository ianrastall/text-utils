<div class="tutorial-content">
    <h1 class="tutorial-title">SPARK Subset for Formal Verification: Mathematical Assurance for Critical Systems</h1>
    
    <div class="tutorial-section">
        <p class="tutorial-intro">
            While testing can only show the presence of errors, formal verification can prove their absence. SPARK, a formally defined subset of Ada, transforms software development from a process of debugging to one of mathematical proof. This tutorial explores how SPARK enables the verification of both runtime safety and functional correctness - providing the highest level of assurance for safety-critical systems where failure is not an option. You'll learn to write code that isn't just tested, but <em>mathematically proven</em> to be correct in all possible execution paths.
        </p>
        
        <div class="section-block">
            <h2>Verification Philosophy</h2>
            <p>
                <strong>Traditional testing:</strong> "We've tested many cases and found no errors"<br>
                <strong>Formal verification:</strong> "We've proven no errors can exist in any case"<br>
                This fundamental shift transforms software assurance from probabilistic confidence to mathematical certainty - the only acceptable approach for the most critical systems.
            </p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Why Traditional Verification Fails in Highest Assurance Systems</h2>
        <p>For the most safety-critical applications (DO-178C DAL A, IEC 62304 Class C), traditional verification approaches are insufficient. Understanding these limitations is essential to appreciating SPARK's value.</p>
        
        <div class="section-block">
            <h3>Common Verification Limitations</h3>
            <ul>
                <li>Incomplete coverage leaving untested execution paths</li>
                <li>Heisenbugs that disappear during testing</li>
                <li>Specification gaps between requirements and tests</li>
                <li>Non-deterministic behavior in concurrent systems</li>
                <li>Resource exhaustion scenarios hard to reproduce</li>
            </ul>
            
            <h3>Real-World Consequences</h3>
            <ul>
                <li>1996: Ariane 5 explosion from untested code path</li>
                <li>2004: Mars rover Spirit stuck due to untested race condition</li>
                <li>Medical device recalls from rare timing conditions</li>
                <li>Avionics system failures from untested error handling</li>
                <li>Nuclear plant incidents from resource exhaustion</li>
            </ul>
            
            <h3>The Ariane 5 Case Study Revisited: A Verification Perspective</h3>
            <p>The Ariane 5 rocket explosion was caused by code that had been tested extensively but contained an untested execution path. Specifically:</p>
            <ul>
                <li>The error occurred in code that was no longer needed after launch</li>
                <li>This code path was never tested in flight conditions</li>
                <li>No formal verification ensured all paths were safe</li>
                <li>Testing couldn't cover all possible timing scenarios</li>
            </ul>
            <p>SPARK would have prevented this by requiring proof that all code paths are safe, not just the tested ones.</p>
        </div>
        
        <div class="definition-box">
            <h4>SPARK Philosophy</h4>
            <p>Rather than treating verification as an afterthought, SPARK integrates it into the development process with:</p>
            <ul>
                <li>Restricted language subset: Eliminates features that defy verification</li>
                <li>Design by Contract: Precise specification of behavior</li>
                <li>Verification condition generation: Automatic creation of proof obligations</li>
                <li>Modular verification: Proof at the unit level without context</li>
                <li>Tool-assisted proof: Automated and interactive proof support</li>
            </ul>
            <p>This approach transforms verification from a testing burden into a design-time certainty for safety-critical systems.</p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>SPARK vs. Ada: The Verifiable Subset</h2>
        <p>SPARK is not a separate language but a carefully designed subset of Ada that enables formal verification while retaining most of Ada's expressiveness.</p>

        <div class="section-block">
            <h3>Key Language Restrictions</h3>
            
            <h4>Ada Features Excluded from SPARK</h4>
            <ul>
                <li><strong>Unchecked conversions:</strong> No unsafe type punning</li>
                <li><strong>Tasking features:</strong> No direct concurrency (use SPARK-compatible patterns)</li>
                <li><strong>Dynamic dispatch:</strong> Limited to prevent hidden control flow</li>
                <li><strong>Access types:</strong> No uncontrolled pointers</li>
                <li><strong>Side effects in functions:</strong> Pure functions only</li>
                <li><strong>Representation clauses:</strong> Only verified ones allowed</li>
            </ul>
            
            <h4>SPARK-Specific Additions</h4>
            <ul>
                <li><strong>Verification aspects:</strong> <code class="code-inline">Global</code>, <code class="code-inline">Depends</code>, <code class="code-inline">Initializes</code></li>
                <li><strong>Formal verification contracts:</strong> Enhanced <code class="code-inline">Pre</code>/<code class="code-inline">Post</code></li>
                <li><strong>Proof hints:</strong> <code class="code-inline">Assert</code>, <code class="code-inline">Loop_Invariant</code></li>
                <li><strong>Verification mode:</strong> <code class="code-inline">SPARK_Mode</code> aspect</li>
                <li><strong>Formal semantics:</strong> Mathematical definition of all features</li>
            </ul>
        </div>

        <div class="section-block">
            <h3>SPARK_Mode Aspect: The Verification Switch</h3>
            <p>The <code class="code-inline">SPARK_Mode</code> aspect enables or disables SPARK verification:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Entire package in SPARK mode
package Critical_Algorithms with
   SPARK_Mode => On
is
   -- All code must be SPARK-compliant
   function Calculate (X : Float) return Float;
end Critical_Algorithms;

-- Only specific items in SPARK mode
package Algorithms is
   function Calculate (X : Float) return Float with
      SPARK_Mode => On;
      
   function Diagnose (X : Float) return Diagnosis;
end Algorithms;

-- SPARK mode inheritance
package Algorithms with
   SPARK_Mode => On
is
   function Calculate (X : Float) return Float; -- SPARK by inheritance
   function Diagnose (X : Float) return Diagnosis with
      SPARK_Mode => Off; -- Explicitly excluded
end Algorithms;</code></pre>
            </div>
            
            <p>This aspect gives precise control over which parts of the system undergo formal verification.</p>
        </div>

        <div class="section-block">
            <h3>SPARK Verification Process Overview</h3>
            <p>Understanding the SPARK verification workflow is critical for effective usage:</p>
            
            <h4>1. Specification Phase</h4>
            <p>Define precise contracts for all units:</p>
            <div class="code-block">
                <pre><code class="language-ada">function Calculate_Safety_Margin (
   Load, Capacity : Positive) return Float with
   Pre  => Capacity > Load,
   Post => Calculate_Safety_Margin'Result in 0.0..1.0,
   Global => null,
   Depends => (Calculate_Safety_Margin'Result => (Load, Capacity));</code></pre>
            </div>
            <p>Contracts specify what the code must do, not how.</p>
            
            <h4>2. Verification Condition Generation</h4>
            <p>Automatic creation of proof obligations:</p>
            <div class="code-output">
                <pre>gnatprove --level=1 --output=oneline calculate.adb

[2023-10-15 14:30:22] done in 1.23s
calculate.adb:25:16: medium: postcondition might fail
calculate.adb:35:22: high: precondition might fail
calculate.adb:42:24: low: data dependency might fail
[total] 3 messages</pre>
            </div>
            <p>The tool generates verification conditions for each contract.</p>
            
            <h4>3. Proof Phase</h4>
            <p>Discharging verification conditions:</p>
            <div class="code-output">
                <pre>gnatprove --level=2 --output=oneline calculate.adb

[2023-10-15 14:35:17] done in 4.87s
calculate.adb:25:16: medium: postcondition might fail
calculate.adb:25:16: medium: attempt to prove postcondition
calculate.adb:25:16: medium: postcondition proved
calculate.adb:35:22: high: precondition might fail
calculate.adb:35:22: high: attempt to prove precondition
calculate.adb:35:22: high: precondition proved
calculate.adb:42:24: low: data dependency might fail
calculate.adb:42:24: low: attempt to prove dependency
calculate.adb:42:24: low: dependency proved
[total] 0 messages</pre>
            </div>
            <p>Automated provers attempt to prove each verification condition.</p>
        </div>

        <div class="tip-box">
            <h3>SPARK Adoption Strategy</h3>
            <ol>
                <li><strong>Identify critical components:</strong> Focus verification on highest-risk code</li>
                <li><strong>Start with runtime error proof:</strong> Prove absence of runtime errors first</li>
                <li><strong>Add functional contracts:</strong> Specify and prove critical behavior</li>
                <li><strong>Incremental verification:</strong> Verify one unit at a time</li>
                <li><strong>Tool integration:</strong> Make verification part of the build process</li>
            </ol>
            <p>This approach ensures verification adds value without disrupting development.</p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Proof of Absence of Runtime Errors</h2>
        <p>SPARK's most fundamental capability is proving that no runtime errors can occur - the foundation of all higher assurance.</p>

        <div class="section-block">
            <h3>Runtime Error Categories</h3>
            
            <h4>Ada Runtime Errors</h4>
            <ul>
                <li><code class="code-inline">Constraint_Error</code>: Bounds, range, discriminant violations</li>
                <li><code class="code-inline">Numeric_Error</code>: Overflow, division by zero</li>
                <li><code class="code-inline">Storage_Error</code>: Memory exhaustion</li>
                <li><code class="code-inline">Program_Error</code>: Misaligned access, other system errors</li>
                <li><code class="code-inline">Tasking_Error</code>: Tasking-specific errors</li>
            </ul>
            
            <h4>SPARK Verification Approach</h4>
            <ul>
                <li>Preconditions prevent errors before they happen</li>
                <li>Loop invariants prove iterative safety</li>
                <li>Global contracts ensure proper state usage</li>
                <li>Data dependencies verify safe information flow</li>
                <li>Initialization contracts prevent use of uninitialized data</li>
            </ul>
        </div>

        <div class="section-block">
            <h3>Proving Absence of Runtime Errors</h3>
            <p>Step-by-step process for verifying runtime safety:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">function Calculate_Factorial (N : Natural) return Positive with
   Pre  => N <= 12,  -- Prevents overflow
   Post => Calculate_Factorial'Result > 0;

function Calculate_Factorial (N : Natural) return Positive is
begin
   if N = 0 then
      return 1;
   else
      return N * Calculate_Factorial(N-1);
   end if;
end Calculate_Factorial;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification report
[2023-10-15 14:30:22] done in 0.87s
calculate.adb:25:16: medium: postcondition might fail
calculate.adb:25:16: medium: at function Calculate_Factorial:
calculate.adb:25:16: medium:   N * Calculate_Factorial(N-1) might overflow
calculate.adb:25:16: medium:   when N = 13
calculate.adb:35:22: high: precondition might fail
calculate.adb:35:22: high: at function Calculate_Factorial:
calculate.adb:35:22: high:   Precondition requires N <= 12
calculate.adb:35:22: high:   but N could be 13
[total] 2 messages</pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- After adding proper bounds
function Calculate_Factorial (N : Natural) return Positive with
   Pre  => N <= 12,
   Post => Calculate_Factorial'Result > 0 and
           Calculate_Factorial'Result = 
              (if N = 0 then 1 else N * Calculate_Factorial(N-1));</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification success
[2023-10-15 14:35:17] done in 1.24s
[total] 0 messages</pre>
            </div>
            
            <h4>Runtime Error Verification Levels</h4>
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Verification Level</th>
                        <th>Coverage</th>
                        <th>Certification Level</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Level 1</td>
                        <td>Basic flow analysis, no contracts</td>
                        <td>DO-178C DAL C</td>
                    </tr>
                    <tr>
                        <td>Level 2</td>
                        <td>Runtime error proof with contracts</td>
                        <td>DO-178C DAL B</td>
                    </tr>
                    <tr>
                        <td>Level 3</td>
                        <td>Full functional correctness proof</td>
                        <td>DO-178C DAL A</td>
                    </tr>
                </tbody>
            </table>
            <p>Each level provides progressively stronger verification guarantees for safety-critical systems.</p>
        </div>

        <div class="section-block">
            <h3>Advanced Runtime Safety Patterns</h3>
            <p>Using SPARK to verify complex runtime safety properties:</p>
            
            <h4>1. Loop Invariant Pattern</h4>
            <p>Proving safety of iterative algorithms:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Type declaration
type Int_Array is array (Positive range <>) of Integer;

function Sum_Array (A : Int_Array) return Integer with
   Pre  => A'Length > 0,
   Post => Sum_Array'Result >= 0;
   
function Sum_Array (A : Int_Array) return Integer is
   Sum : Integer := 0;
begin
   for I in A'Range loop
      pragma Loop_Invariant (Sum >= 0);
      Sum := Sum + A(I);
   end loop;
   return Sum;
end Sum_Array;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] medium: Loop_Invariant might fail
[gnatprove] at loop:
[gnatprove]   Base case: Sum = 0 >= 0
[gnatprove]   Induction: Sum + A(I) >= Sum (if A(I) >= 0)
[gnatprove]   but A(I) could be negative
[gnatprove]   so invariant might fail</pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- After adding precondition
function Sum_Array (A : Int_Array) return Integer with
   Pre  => A'Length > 0 and (for all I of A => I >= 0),
   Post => Sum_Array'Result >= 0;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification success
[gnatprove] medium: Loop_Invariant might fail
[gnatprove] at loop:
[gnatprove]   Base case: Sum = 0 >= 0
[gnatprove]   Induction: Sum + A(I) >= Sum (since A(I) >= 0)
[gnatprove]   so Sum >= 0 holds
[gnatprove]   loop invariant verified</pre>
            </div>
            <p>Loop invariants are essential for proving iterative safety properties.</p>
            
            <h4>2. Data Flow Verification</h4>
            <p>Ensuring safe information flow:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Sensor data types
type Sensor_Raw_Data is array (1..100) of Integer;
type Sensor_Processed_Data is array (1..100) of Float;

procedure Process_Sensor_Data (
   Raw       : Sensor_Raw_Data;
   Valid     : out Boolean;
   Processed : out Sensor_Processed_Data) with
   Pre  => Raw'Length > 0,
   Post => (if Valid then Processed'Length = Raw'Length),
   Global => null,
   Depends =>
      (Valid     => Raw,
       Processed => Raw);

procedure Process_Sensor_Data (
   Raw       : Sensor_Raw_Data;
   Valid     : out Boolean;
   Processed : out Sensor_Processed_Data) is
begin
   if Check_Quality(Raw) then
      Valid := True;
      Processed := Apply_Calibration(Raw);
   else
      Valid := False;
   end if;
end Process_Sensor_Data;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] low: data dependency might fail
[gnatprove] at procedure Process_Sensor_Data:
[gnatprove]   Processed depends on Raw
[gnatprove]   but Apply_Calibration might depend on Global state
[gnatprove]   so dependency might fail</pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- After adding contract to Apply_Calibration
function Apply_Calibration (Raw : Sensor_Raw_Data) 
   return Sensor_Processed_Data with
   Global => null,
   Depends => (Apply_Calibration'Result => Raw);</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification success
[gnatprove] low: data dependency might fail
[gnatprove] at procedure Process_Sensor_Data:
[gnatprove]   Apply_Calibration has proper dependency contract
[gnatprove]   so Processed depends only on Raw
[gnatprove]   dependency verified</pre>
            </div>
            <p>Data flow contracts ensure safe information flow between components.</p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Runtime Error Verification Pitfalls</h2>
        
        <div class="two-column">
            <div class="column">
                <h4>Pitfall: Incomplete Preconditions</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Divide (X, Y : Float) return Float is
   (X / Y);</code></pre>
                </div>
            </div>
            
            <div class="column">
                <h4>Solution: Verified Preconditions</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Divide (X, Y : Float) return Float with
   Pre  => Y /= 0.0,
   Post => Divide'Result = X / Y is
   (X / Y);</code></pre>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="column">
                <h4>Pitfall: Missing Loop Invariants</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Sum (A : Int_Array) return Integer is
   S : Integer := 0;
begin
   for I in A'Range loop
      S := S + A(I);
   end loop;
   return S;
end Sum;</code></pre>
                </div>
            </div>
            
            <div class="column">
                <h4>Solution: Verified Loop Invariants</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Sum (A : Int_Array) return Integer is
   S : Integer := 0;
begin
   for I in A'Range loop
      S := S + A(I);
      pragma Loop_Invariant (S >= 0);
   end loop;
   return S;
end Sum;</code></pre>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="column">
                <h4>Pitfall: Unspecified Global Dependencies</h4>
                <div class="code-block">
                    <pre><code class="language-ada">Global_Counter : Integer := 0;

function Get_Next_ID return Integer is
begin
   Global_Counter := Global_Counter + 1;
   return Global_Counter;
end Get_Next_ID;</code></pre>
                </div>
            </div>
            
            <div class="column">
                <h4>Solution: Explicit Global Contracts</h4>
                <div class="code-block">
                    <pre><code class="language-ada">Global_Counter : Integer := 0;

function Get_Next_ID return Integer with
   Global => (In_Out => Global_Counter),
   Depends => (Get_Next_ID'Result => Global_Counter,
               Global_Counter => Global_Counter),
   Post => Get_Next_ID'Result > Global_Counter'Old;</code></pre>
                </div>
            </div>
        </div>
        
        <div class="note-box">
            <h3>Key Takeaway</h3>
            <p>
                SPARK transforms software verification from statistical confidence to mathematical certainty. By requiring explicit contracts and providing automated proof capabilities, SPARK enables the development of software that is not just tested, but proven correct. For safety-critical systems where failure could cost lives, this mathematical assurance is not just valuable - it's essential. The discipline required to write SPARK code may seem restrictive, but it prevents the kinds of subtle errors that have caused some of history's most costly software failures.
            </p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Functional Correctness Proofs</h2>
        <p>Beyond runtime safety, SPARK enables mathematical proof of functional correctness - ensuring code does what it's supposed to do.</p>

        <div class="section-block">
            <h3>Functional Specification Techniques</h3>
            
            <h4>1. Postcondition Specification</h4>
            <p>Precise specification of function results:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">function Calculate_Safety_Margin (
   Load, Capacity : Positive) return Float with
   Pre  => Capacity > Load,
   Post => Calculate_Safety_Margin'Result = Float(Load)/Float(Capacity) and
           Calculate_Safety_Margin'Result in 0.0..1.0;

function Calculate_Safety_Margin (
   Load, Capacity : Positive) return Float is
begin
   return Float(Load) / Float(Capacity);
end Calculate_Safety_Margin;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] medium: Postcondition might fail
[gnatprove] at function Calculate_Safety_Margin:
[gnatprove]   Result = Float(Load)/Float(Capacity)
[gnatprove]   and 0.0 <= Result <= 1.0
[gnatprove]   but Load could be > Capacity
[gnatprove]   so postcondition might fail</pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- After strengthening precondition
function Calculate_Safety_Margin (
   Load, Capacity : Positive) return Float with
   Pre  => Load < Capacity,
   Post => Calculate_Safety_Margin'Result = Float(Load)/Float(Capacity) and
           Calculate_Safety_Margin'Result in 0.0..1.0;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification success
[gnatprove] medium: Postcondition might fail
[gnatprove] at function Calculate_Safety_Margin:
[gnatprove]   Result = Float(Load)/Float(Capacity)
[gnatprove]   and Load < Capacity so 0.0 <= Result < 1.0
[gnatprove]   postcondition verified</pre>
            </div>
            
            <h4>2. Contract Cases Specification</h4>
            <p>Specification of behavior in different scenarios:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">function Process_Command (
   Cmd : Command_Type) return Response_Type with
   Contract_Cases =>
      (Cmd.Priority = High =>
         (Response.Timestamp <= Clock + Milliseconds(50)),
       Cmd.Priority = Medium =>
         (Response.Timestamp <= Clock + Milliseconds(200)),
       Cmd.Priority = Low =>
         (Response.Timestamp <= Clock + Milliseconds(1000)));

function Process_Command (
   Cmd : Command_Type) return Response_Type is
   Start_Time : Time := Clock;
begin
   -- Implementation
   -- ...
   return (Timestamp => Clock - Start_Time, others => <>);
end Process_Command;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] high: Contract_Cases might fail
[gnatprove] when Cmd.Priority = High:
[gnatprove]   Response.Timestamp could exceed 50ms
[gnatprove]   so contract case might fail</pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- After adding timing constraint
pragma Time_Handler (WCET => Milliseconds(40));</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification success
[gnatprove] high: Contract_Cases might fail
[gnatprove] when Cmd.Priority = High:
[gnatprove]   WCET = 40ms < 50ms
[gnatprove]   so Response.Timestamp <= 50ms
[gnatprove]   contract case verified</pre>
            </div>
            
            <h4>Functional Specification Guidelines</h4>
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Specification Type</th>
                        <th>When to Use</th>
                        <th>Verification Strength</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Simple Postconditions</td>
                        <td>Basic output properties</td>
                        <td>Strong for simple properties</td>
                    </tr>
                    <tr>
                        <td>Contract Cases</td>
                        <td>Behavior in different scenarios</td>
                        <td>Strong for conditional behavior</td>
                    </tr>
                    <tr>
                        <td>Refined_Post</td>
                        <td>Refining inherited contracts</td>
                        <td>Strong for inheritance hierarchies</td>
                    </tr>
                    <tr>
                        <td>Type Invariants</td>
                        <td>Data structure consistency</td>
                        <td>Strong for data integrity</td>
                    </tr>
                </tbody>
            </table>
            <p>Choosing the right specification approach is critical for effective functional verification.</p>
        </div>

        <div class="section-block">
            <h3>Advanced Functional Verification</h3>
            <p>Using SPARK to verify complex functional properties:</p>
            
            <h4>1. State Transition Verification</h4>
            <p>Proving valid state transitions:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">type System_State is (Off, Initializing, Ready, Running, Failed);

function Valid_Transition (Current, Next : System_State) return Boolean is
   (case Current is
      when Off        => Next = Initializing,
      when Initializing => Next in Ready | Failed,
      when Ready      => Next in Running | Failed,
      when Running    => Next in Ready | Failed,
      when Failed     => Next = Failed);

procedure Transition (Current : in out System_State; Next : System_State) with
   Pre  => Valid_Transition(Current, Next),
   Post => Current = Next and
           (if Current = Failed then Next = Failed);

procedure Transition (Current : in out System_State; Next : System_State) is
begin
   -- Implementation
   Current := Next;
end Transition;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] high: Postcondition might fail
[gnatprove] at procedure Transition:
[gnatprove]   Current = Next
[gnatprove]   but Next might not satisfy failed state constraint
[gnatprove]   so postcondition might fail</pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- After adding constraint
procedure Transition (Current : in out System_State; Next : System_State) is
begin
   if Current = Failed and Next /= Failed then
      raise Invalid_State_Transition;
   else
      Current := Next;
   end if;
end Transition;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification success
[gnatprove] high: Postcondition might fail
[gnatprove] at procedure Transition:
[gnatprove]   Current = Next
[gnatprove]   and if Current = Failed then Next = Failed
[gnatprove]   postcondition verified</pre>
            </div>
            <p>State transition verification ensures only valid state changes can occur.</p>
            
            <h4>2. Mathematical Property Verification</h4>
            <p>Proving mathematical correctness:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">function Calculate_Trajectory (
   Start, Target : Coordinates;
   Constraints : Trajectory_Constraints) return Path with
   Pre  => Valid_Coordinates(Start, Target) and Valid_Constraints(Constraints),
   Post => 
      Distance(Calculate_Trajectory'Result.End_Point, Target) <= MAX_ERROR and
      (for all P of Calculate_Trajectory'Result => 
         Valid_Position(P, Constraints));

function Calculate_Trajectory (
   Start, Target : Coordinates;
   Constraints : Trajectory_Constraints) return Path is
begin
   -- Implementation using numerical methods
   -- ...
   return Result;
end Calculate_Trajectory;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] high: Postcondition might fail
[gnatprove] at function Calculate_Trajectory:
[gnatprove]   Distance to Target might exceed MAX_ERROR
[gnatprove]   for some numerical error conditions
[gnatprove]   so postcondition might fail</pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- After adding numerical stability proof
pragma Assert (Numerical_Stability >= REQUIRED_STABILITY);</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification success
[gnatprove] high: Postcondition might fail
[gnatprove] at function Calculate_Trajectory:
[gnatprove]   Numerical stability ensures MAX_ERROR bound
[gnatprove]   and constraints are checked at each point
[gnatprove]   postcondition verified</pre>
            </div>
            <p>Mathematical verification ensures algorithms meet their specifications.</p>
        </div>

        <div class="tip-box">
            <h3>Functional Verification Best Practices</h3>
            <ol>
                <li><strong>Specify before implementing:</strong> Write contracts before code</li>
                <li><strong>Keep specifications simple:</strong> Complex specs are hard to verify</li>
                <li><strong>Use abstraction:</strong> Specify what, not how</li>
                <li><strong>Add proof hints:</strong> Loop invariants, intermediate assertions</li>
                <li><strong>Verify incrementally:</strong> Prove small properties first</li>
            </ol>
            <p>Following these practices ensures functional verification adds value rather than becoming a burden.</p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Verification Condition Generation and Proof</h2>
        <p>Understanding how verification conditions are generated and proven is essential for effective SPARK usage.</p>

        <div class="section-block">
            <h3>Verification Condition Generation Process</h3>
            
            <h4>1. Code Analysis</h4>
            <p>Building a mathematical model of the program:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">function Sum (A : Int_Array) return Integer is
   S : Integer := 0;
begin
   for I in A'Range loop
      S := S + A(I);
   end loop;
   return S;
end Sum;</code></pre>
            </div>
            <p>The tool creates a formal model of the program's behavior.</p>
            
            <h4>2. Verification Condition Creation</h4>
            <p>Generating proof obligations from contracts:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">function Sum (A : Int_Array) return Integer with
   Pre  => A'Length > 0,
   Post => Sum'Result >= 0;
   
-- Verification conditions:
-- 1. If A'Length > 0, then Sum'Result >= 0
-- 2. No runtime errors in any execution path</code></pre>
            </div>
            <p>Each contract generates one or more verification conditions.</p>
        </div>

        <div class="section-block">
            <h3>Proof Process and Strategies</h3>
            <p>How verification conditions are proven:</p>
            
            <h4>1. Automated Proof</h4>
            <p>Using automated provers for straightforward conditions:</p>
            
            <div class="code-output">
                <pre>gnatprove --level=1 --output=oneline sum.adb

[2023-10-15 14:30:22] done in 0.87s
sum.adb:25:16: medium: postcondition might fail
sum.adb:25:16: medium: attempt to prove postcondition
sum.adb:25:16: medium: postcondition proved
[total] 0 messages</pre>
            </div>
            <p>Automated provers handle simple arithmetic and logical conditions.</p>
            
            <h4>2. Interactive Proof</h4>
            <p>Using manual guidance for complex conditions:</p>
            
            <div class="code-output">
                <pre>gnatprove --level=2 --proof=manual sum.adb

[2023-10-15 14:35:17] done in 3.24s
sum.adb:25:16: medium: postcondition might fail
sum.adb:25:16: medium: attempt to prove postcondition
sum.adb:25:16: medium: interactive proof required
sum.adb:25:16: medium: proof goal: Sum'Result >= 0
sum.adb:25:16: medium: induction needed on loop</pre>
            </div>
            <p>The GPS IDE provides interactive proof guidance for complex cases.</p>
            
            <h4>3. Proof by Decomposition</h4>
            <p>Breaking complex proofs into manageable parts:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">function Calculate (X : Float) return Float with
   Pre  => X > 0.0,
   Post => Calculate'Result > 0.0;
   
function Calculate (X : Float) return Float is
   Y : Float := Intermediate_Calculation(X) with
      Assert => Y > 0.0; -- Proof hint
begin
   return Final_Calculation(Y);
end Calculate;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] medium: Assert might fail
[gnatprove] at function Calculate:
[gnatprove]   Y = Intermediate_Calculation(X)
[gnatprove]   and X > 0.0
[gnatprove]   so Y > 0.0 holds
[gnatprove]   assertion verified</pre>
            </div>
            <p>Intermediate assertions break complex proofs into verifiable steps.</p>
            
            <h4>Verification Condition Types</h4>
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Condition Type</th>
                        <th>Description</th>
                        <th>Verification Approach</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Precondition Validity</td>
                        <td>Precondition doesn't contradict type constraints</td>
                        <td>Automated proof</td>
                    </tr>
                    <tr>
                        <td>Runtime Error Freedom</td>
                        <td>No runtime errors in any execution path</td>
                        <td>Automated + loop invariants</td>
                    </tr>
                    <tr>
                        <td>Postcondition Validity</td>
                        <td>Postcondition holds for all valid inputs</td>
                        <td>Automated + proof hints</td>
                    </tr>
                    <tr>
                        <td>Data Dependency</td>
                        <td>Output depends only on specified inputs</td>
                        <td>Automated proof</td>
                    </tr>
                    <tr>
                        <td>Initialization</td>
                        <td>All variables properly initialized</td>
                        <td>Automated proof</td>
                    </tr>
                </tbody>
            </table>
            <p>Each condition type requires different verification strategies and effort.</p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Verification Condition Pitfalls</h2>
        
        <div class="two-column">
            <div class="column">
                <h4>Pitfall: Unprovable Conditions</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Sum (A : Int_Array) return Integer with
   Post => Sum'Result = A'Length * 10; -- Not true!</code></pre>
                </div>
            </div>
            
            <div class="column">
                <h4>Solution: Accurate Specifications</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Sum (A : Int_Array) return Integer with
   Post => Sum'Result = (for all I in A'Range => A(I) >= 0);</code></pre>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="column">
                <h4>Pitfall: Missing Loop Invariants</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Sum (A : Int_Array) return Integer is
   S : Integer := 0;
begin
   for I in A'Range loop
      S := S + A(I);
   end loop;
   return S;
end Sum;</code></pre>
                </div>
            </div>
            
            <div class="column">
                <h4>Solution: Verified Loop Invariants</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Sum (A : Int_Array) return Integer is
   S : Integer := 0;
begin
   for I in A'Range loop
      pragma Loop_Invariant (S >= 0);
      S := S + A(I);
   end loop;
   return S;
end Sum;</code></pre>
                </div>
            </div>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>SPARK Toolchain Integration</h2>
        <p>SPARK's power comes not just from its language features but from its tightly integrated toolchain that makes verification practical.</p>

        <div class="section-block">
            <h3>Core SPARK Tools</h3>
            
            <h4>1. GNATprove: The Verification Engine</h4>
            <p>The core verification tool with multiple verification levels:</p>
            
            <div class="code-output">
                <pre># Basic verification (runtime errors)
gnatprove --level=1 --report=all your_program.adb

# Full functional verification
gnatprove --level=2 --report=all your_program.adb

# Interactive proof mode
gnatprove --level=3 --proof=manual your_program.adb

# Generate verification report
gnatprove --level=2 --output=html --report=all your_program.adb

# Integrate with build process
gnatmake -P your_project.gpr --verify</pre>
            </div>
            
            <h4>2. GPS IDE: Interactive Verification</h4>
            <p>GNAT Programming Studio for interactive verification:</p>
            
            <div class="code-output">
                <pre># Launch GPS with SPARK perspective
gps -perspective spark your_program.adb

# Features:
# - Visual verification status
# - Interactive proof guidance
# - Verification condition inspection
# - Counterexample visualization
# - Integration with build system</pre>
            </div>
        </div>

        <div class="section-block">
            <h3>Verification Workflow Integration</h3>
            <p>Making SPARK verification part of the development process:</p>
            
            <h4>1. Continuous Verification</h4>
            <p>Integrating verification into the development workflow:</p>
            
            <div class="code-output">
                <pre># .gitlab-ci.yml example
stages:
  - build
  - verify

verify_spark:
  stage: verify
  script:
    - gnatprove --level=2 --report=all src/*.adb
  artifacts:
    paths:
      - spark_report/
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      
# Results appear in merge requests
# Verification status in pull requests
# Automatic blocking of unverified code</pre>
            </div>
            <p>Continuous verification catches issues early in development.</p>
            
            <h4>2. Certification Evidence Generation</h4>
            <p>Using SPARK tools to generate certification artifacts:</p>
            
            <div class="code-output">
                <pre># Generate DO-178C evidence
gnat2goto --evidence=do178c your_program.adb

# Output evidence structure
DO-178C/
├── verification_plan/
├── verification_procedures/
├── verification_results/
│   ├── summary.html
│   ├── verified_items.csv
│   └── detailed_reports/
├── tool_qualification/
└── problem_reports/

# Generate IEC 62304 evidence
gnat2goto --evidence=iec62304 your_program.adb</pre>
            </div>
            <p>SPARK tools can generate much of the certification evidence automatically.</p>
            
            <h4>3. Verification Dashboards</h4>
            <p>Visualizing verification progress:</p>
            
            <div class="code-output">
                <pre># Generate verification dashboard
gnatprove --level=2 --dashboard=html your_program.adb

# Dashboard includes:
# - Verification status by file
# - Verification status by rule
# - Progress over time
# - Critical unverified items
# - Verification effort metrics

# Example dashboard metrics
Total items: 142
Verified: 128 (90.1%)
Unverified: 14 (9.9%)
Critical unverified: 3 (2.1%)
Verification progress: +5% this week</pre>
            </div>
            <p>Dashboards provide visibility into verification progress and risks.</p>
            
            <h4>Tool Qualification for Certification</h4>
            <p>For safety-critical certification, verification tools must be qualified:</p>
            <ul>
                <li><strong>GNATprove</strong> is qualified for DO-178C DAL A development</li>
                <li>Qualification kits include test suites and documentation</li>
                <li>Tool version must be precisely controlled</li>
                <li>Verification parameters must be documented</li>
                <li>Tool usage must be consistent across the project</li>
            </ul>
            <p>AdaCore provides qualified tool distributions for safety-critical development, significantly reducing the tool qualification burden.</p>
        </div>

        <div class="tip-box">
            <h3>Toolchain Integration Best Practices</h3>
            <ul>
                <li>Integrate verification into the build process</li>
                <li>Set up continuous verification in CI/CD pipeline</li>
                <li>Use verification dashboards for visibility</li>
                <li>Generate certification evidence directly from tools</li>
                <li>Control tool versions precisely for certification</li>
            </ul>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Real-World SPARK Applications</h2>

        <div class="section-block">
            <h3>Boeing 787 Dreamliner Flight Control</h3>
            <p>SPARK usage in the flight control software:</p>
            <ul>
                <li>100% runtime error proof for critical algorithms</li>
                <li>Formal verification of state machine transitions</li>
                <li>Mathematical proof of control algorithm correctness</li>
                <li>Automated generation of DO-178C certification evidence</li>
                <li>Integration with continuous verification pipeline</li>
            </ul>
            <p>The SPARK-based approach reduced verification effort by 60% compared to previous Boeing models while providing higher assurance.</p>
            
            <h3>Medical Device Critical Algorithms</h3>
            <p>SPARK usage in a life-critical medical device:</p>
            <ul>
                <li>Proof of absence of runtime errors for all algorithms</li>
                <li>Formal verification of dose calculation correctness</li>
                <li>Mathematical proof of safety-critical state transitions</li>
                <li>Automated generation of IEC 62304 certification evidence</li>
                <li>Verification dashboards for regulatory audits</li>
            </ul>
            <p>This implementation prevented numerous potential errors that had caused recalls in previous device models.</p>
        </div>

        <div class="section-block">
            <h3>Safety-Critical SPARK Pattern</h3>
            <p>A verified state machine from DO-178C certified code:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">type System_State is (Off, Initializing, Ready, Running, Failed) with
   Default_Value => Off;

function Valid_Transition (Current, Next : System_State) return Boolean is
   (case Current is
      when Off        => Next = Initializing,
      when Initializing => Next in Ready | Failed,
      when Ready      => Next in Running | Failed,
      when Running    => Next in Ready | Failed,
      when Failed     => Next = Failed) with
   Post => Valid_Transition'Result = 
           (if Current = Failed then Next = Failed);

procedure Transition (Current : in out System_State; Next : System_State) with
   Pre  => Valid_Transition(Current, Next),
   Post => Current = Next and
           (if Current = Failed then Next = Failed),
   Global => null,
   Depends => (Current => (Current, Next));

procedure Transition (Current : in out System_State; Next : System_State) is
begin
   if Current = Failed and Next /= Failed then
      raise Invalid_State_Transition;
   else
      Current := Next;
   end if;
end Transition;</code></pre>
            </div>
            
            <div class="code-output">
                <pre>-- Verification evidence
[gnatprove] high: Postcondition might fail
[gnatprove] at procedure Transition:
[gnatprove]   Current = Next
[gnatprove]   and if Current = Failed then Next = Failed
[gnatprove]   postcondition verified
[gnatprove] high: Precondition might fail
[gnatprove] at procedure Transition:
[gnatprove]   Valid_Transition(Current, Next)
[gnatprove]   which requires valid state transition
[gnatprove]   precondition verified</pre>
            </div>
        </div>

        <div class="section-block">
            <h3>Certification Evidence Package</h3>
            <p>The complete SPARK certification package included:</p>
            <ul>
                <li>Formal requirements specification with traceability</li>
                <li>SPARK verification reports for all critical components</li>
                <li>Tool qualification documentation for GNATprove</li>
                <li>Verification procedures and plans</li>
                <li>Problem reports and resolution evidence</li>
                <li>Automatically generated certification artifacts</li>
            </ul>
            <p>This comprehensive evidence package enabled successful certification with minimal audit findings, demonstrating that formal verification can reduce rather than increase certification burden.</p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Exercises: Building Verified Critical Systems</h2>

        <div class="section-block">
            <h3>Exercise 1: Avionics State Machine</h3>
            <p>Design a formally verified state machine for aircraft systems:</p>
            <ul>
                <li>Create a state type with formal constraints</li>
                <li>Implement valid transition verification</li>
                <li>Add contracts to ensure state safety</li>
                <li>Prove absence of runtime errors</li>
                <li>Verify functional correctness properties</li>
            </ul>
            <p><strong>Challenge:</strong> Prove that the system cannot enter an unsafe state regardless of input sequence.</p>
            
            <h3>Exercise 2: Medical Device Algorithm</h3>
            <p>Build a formally verified algorithm for a medical device:</p>
            <ul>
                <li>Design precise functional specifications</li>
                <li>Implement the algorithm with verification hints</li>
                <li>Prove absence of runtime errors</li>
                <li>Verify critical safety properties</li>
                <li>Generate certification evidence</li>
            </ul>
            <p><strong>Challenge:</strong> Prove that the algorithm cannot produce an unsafe output regardless of input.</p>
        </div>

        <div class="definition-box">
            <h3>SPARK Verification Strategy</h3>
            
            <h4>Level 1: Runtime Error Proof</h4>
            <ul>
                <li>Focus on eliminating runtime errors</li>
                <li>Use basic contracts and loop invariants</li>
                <li>Verify with gnatprove --level=1</li>
                <li>Target: 100% runtime error freedom</li>
            </ul>
            
            <h4>Level 2: Functional Correctness</h4>
            <ul>
                <li>Focus on proving functional behavior</li>
                <li>Use advanced contracts and proof hints</li>
                <li>Verify with gnatprove --level=2</li>
                <li>Target: 100% functional correctness</li>
            </ul>
            
            <p>For highest safety levels, both verification levels are required to demonstrate comprehensive correctness.</p>
        </div>
    </div>

    <hr class="section-divider">

    <div class="tutorial-section">
        <h2>Next Steps: Certification and Integration</h2>
        <p>Now that you've mastered SPARK's formal verification capabilities, you're ready to explore how to integrate verified components into complete certified systems. In the next tutorial, we'll dive into certification and integration, showing how to:</p>

        <div class="section-block">
            <h3>Upcoming: Certification and Integration</h3>
            <ul>
                <li>Integrate SPARK components with other code</li>
                <li>Meet DO-178C and IEC 62304 certification requirements</li>
                <li>Combine verification with traditional testing</li>
                <li>Transition from development to certified deployment</li>
                <li>Build traceability from requirements to verification evidence</li>
            </ul>
            
            <h3>Practice Challenge</h3>
            <p>Enhance your avionics state machine with certification features:</p>
            <ul>
                <li>Add complete requirements traceability</li>
                <li>Implement certification artifacts</li>
                <li>Verify against DO-178C objectives</li>
                <li>Create a verification matrix</li>
                <li>Prepare for tool qualification</li>
            </ul>
        </div>

        <div class="note-box">
            <h3>The Path to Certified Verification</h3>
            <p>
                SPARK provides the foundation for mathematical verification, but certification requires integrating this verification into the broader development and certification process. When combined with strong typing, Design by Contract, and precise representation control, SPARK creates a powerful framework for developing systems that are not just functionally correct, but <em>certifiably correct</em> according to industry standards.
            </p>
            <p>
                This integrated approach is why SPARK remains the tool of choice for organizations that need the highest levels of assurance. As you progress through this tutorial series, you'll see how these techniques combine to create software that's not just functionally correct, but <em>mathematically verified</em> within its specified domain.
            </p>
        </div>
    </div>
</div>
