<div class="tutorial-content">
    <h1 class="tutorial-title">Safety-Critical GUI Development: Interface Design for Human-Machine Interaction in Certified Systems</h1>
    
    <div class="tutorial-section">
        <h2>Introduction: The Critical Role of Human-Machine Interfaces</h2>
        <div class="section-block">
            <p>In safety-critical systems—from aircraft cockpits to medical infusion pumps—the human-machine interface (HMI) serves as the vital link between complex automated systems and human operators. While the graphical user interface (GUI) itself is rarely part of the safety-critical path, its design, implementation, and integration with safety-critical components directly impact system safety. Traditional approaches often treat the GUI as an afterthought, creating dangerous integration points where interface errors can compromise otherwise robust safety systems. This tutorial examines how Ada enables the development of HMIs that safely and reliably interact with safety-critical components while maintaining appropriate separation of concerns.</p>
            
            <p><strong>Ada Philosophy:</strong> Safety-critical systems require <em>clear architectural boundaries</em> between safety-critical components and user interfaces. The language must support robust interface design that prevents UI errors from compromising safety functions while enabling verifiable communication patterns.</p>
            
            <p>Unlike general-purpose application development, safety-critical GUI design must address unique challenges: preventing interface-induced errors, ensuring fail-safe transitions, maintaining system awareness during degraded operation, and providing unambiguous status information. This tutorial explores how Ada's strong typing, formal verification capabilities, and architectural patterns support the development of HMIs that enhance rather than compromise system safety. We'll examine the proper role of GtkAda in safety-critical architectures and how to verify the critical interfaces between UI components and safety-critical logic.</p>
        </div>
    </div>
    
    <hr class="section-divider">
    
    <div class="tutorial-section">
        <h2>Why Traditional GUI Approaches Fail in Safety-Critical Contexts</h2>
        <div class="section-block">
            <p>Conventional GUI development practices, particularly those borrowed from consumer applications, introduce significant risks when applied to safety-critical systems. The fundamental mismatch between typical GUI frameworks and safety requirements creates hidden failure modes that often only manifest during operational use.</p>
            
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Problem (Traditional Approach)</th>
                        <th>Consequence in Safety-Critical Systems</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Tight coupling between UI and business logic</td>
                        <td>UI errors directly compromise safety logic; single point of failure</td>
                    </tr>
                    <tr>
                        <td>Event-driven programming without determinism</td>
                        <td>Unpredictable response timing; missed critical events during UI rendering</td>
                    </tr>
                    <tr>
                        <td>Dynamic memory allocation in UI framework</td>
                        <td>Memory fragmentation leads to delayed or missed safety-critical operations</td>
                    </tr>
                    <tr>
                        <td>Complex UI frameworks with undefined behavior</td>
                        <td>Framework bugs become system safety hazards; impossible to fully verify</td>
                    </tr>
                    <tr>
                        <td>Lack of architectural boundaries</td>
                        <td>UI errors propagate to safety-critical components; no fail-safe degradation</td>
                    </tr>
                    <tr>
                        <td>Insufficient status feedback design</td>
                        <td>Operators make decisions based on incomplete or ambiguous system state information</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Case Study: Medical Infusion Pump Interface Failure</h3>
            <div class="note-box">
                <p>A widely-deployed medical infusion pump experienced numerous incidents where clinicians accidentally administered overdose medications. The root cause was traced to a poorly designed interface where critical safety parameters were buried in multiple menu layers, and the confirmation dialog lacked visual distinction between "Start" and "Stop" actions. The UI framework was tightly coupled with the dose calculation logic, allowing interface errors to directly affect delivery rates.</p>
                
                <p><strong>Ada Perspective:</strong> Proper architectural separation would have isolated the safety-critical dose calculation and delivery mechanisms from the UI components. Formal interface specifications would have prevented invalid parameter transitions, and verification of the communication channels would have ensured fail-safe behavior during UI errors. This tutorial will demonstrate how to implement these critical safeguards.</p>
            </div>
            
            <p><strong>Safety-Critical HMI Philosophy:</strong> The human-machine interface must <em>enhance system safety</em> through clear architectural boundaries, unambiguous status presentation, and fail-safe integration with safety-critical components. UI errors must never compromise safety functions, and the interface must provide operators with accurate, timely information to support safe decision-making.</p>
        </div>
    </div>
    
    <hr class="section-divider">
    
    <div class="tutorial-section">
        <h2>Fundamentals of Safety-Critical HMI Architecture</h2>
        <div class="section-block">
            <p>The foundation of safety-critical GUI development is proper architectural design. Unlike conventional applications, safety-critical systems require strict separation between safety-critical components and user interface elements. This section examines the architectural patterns essential for safe HMI integration.</p>
            
            <h3>Architectural Separation Principles</h3>
            <p>Safety-critical systems follow these fundamental architectural principles:</p>
            
            <div class="two-column">
                <div class="column">
                    <h4>Partitioning Strategy</h4>
                    <ul>
                        <li><strong>Level A/B components:</strong> Safety-critical logic (DO-178C)</li>
                        <li><strong>Level C/D components:</strong> User interface elements</li>
                        <li><strong>Clear interface:</strong> Well-defined communication channels</li>
                        <li><strong>Directional flow:</strong> Data flows from safety to UI, not vice versa</li>
                        <li><strong>Verification boundary:</strong> Interface is formally verified</li>
                    </ul>
                </div>
                <div class="column">
                    <h4>Interface Design Constraints</h4>
                    <ul>
                        <li>Minimal data transfer across boundary</li>
                        <li>No direct function calls across boundary</li>
                        <li>Stateless communication where possible</li>
                        <li>Fail-safe defaults for all interface parameters</li>
                        <li>Explicit validation of all UI inputs</li>
                    </ul>
                </div>
            </div>
            
            <h3>Typical Safety-Critical HMI Architecture</h3>
            <p>A properly designed safety-critical system architecture looks like this:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Safety-Critical Partition (Level A/B)
package Flight_Control with SPARK_Mode is
   
   -- Safety-critical state
   type Flight_Mode is (Normal, Emergency, Degraded);
   Current_Mode : Flight_Mode := Normal with Volatile;
   
   -- Critical flight parameters
   type Altitude is delta 0.1 range 0.0 .. 50000.0;
   Current_Altitude : Altitude := 0.0 with Volatile;
   
   -- Safety-critical operations
   procedure Set_Altitude_Target (Target : Altitude);
   function Get_Flight_Status return String;
   
   -- UI interface (output only)
   procedure Get_UI_State (Mode : out Flight_Mode; Altitude : out Altitude);
   
private
   Target_Altitude : Altitude := 0.0;
   -- Additional safety-critical state...
end Flight_Control;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- UI Partition (Level D)
with Flight_Control; -- Only interface, not implementation

package Flight_Display is
   
   -- UI state derived from safety-critical system
   type Display_Mode is (Normal_View, Warning_View, Emergency_View);
   Current_View : Display_Mode := Normal_View;
   
   -- Update display from safety-critical system
   procedure Update_Display is
      Mode : Flight_Control.Flight_Mode;
      Altitude : Flight_Control.Altitude;
   begin
      Flight_Control.Get_UI_State (Mode, Altitude);
      
      case Mode is
         when Flight_Control.Normal =>
            Current_View := Normal_View;
            Draw_Normal_Display (Altitude);
            
         when Flight_Control.Emergency =>
            Current_View := Emergency_View;
            Activate_Warning_Lights;
            Draw_Emergency_Display (Altitude);
            
         when others =>
            Current_View := Warning_View;
            Draw_Warning_Display (Altitude);
      end case;
   end Update_Display;
   
   -- UI inputs (never directly affect safety logic)
   procedure Handle_User_Input (Input : User_Action) is
      Valid_Input : Boolean;
      Target : Flight_Control.Altitude;
   begin
      -- Validate input against safety constraints
      Validate_Input (Input, Valid_Input, Target);
      
      if Valid_Input then
         -- Only send validated input to safety system
         Flight_Control.Set_Altitude_Target (Target);
      else
         -- Handle invalid input safely
         Log_Invalid_Input (Input);
         Trigger_Input_Warning;
      end if;
   end Handle_User_Input;
   
private
   -- Input validation must be rigorous
   procedure Validate_Input 
     (Input        : User_Action;
      Is_Valid     : out Boolean;
      Target_Value : out Flight_Control.Altitude);
end Flight_Display;</code></pre>
            </div>
            
            <div class="tip-box">
                <p><strong>Critical Architecture Note:</strong> The safety-critical partition <em>never</em> calls directly into the UI partition. All communication flows from safety-critical to UI (status updates) or through validated inputs from UI to safety (commands). This directional constraint is essential for preventing UI errors from compromising safety.</p>
            </div>
            
            <div class="note-box">
                <p><strong>Best Practice:</strong> For DO-178C Level A systems, implement the interface between safety-critical and UI partitions using a formally verified communication channel with explicit validation on both sides of the boundary.</p>
            </div>
        </div>
    </div>
    
    <hr class="section-divider">
    
    <div class="tutorial-section">
        <h2>The Role of GtkAda in Safety-Critical Systems</h2>
        <div class="section-block">
            <p>GtkAda provides Ada bindings to the GTK graphical toolkit, but its role in safety-critical systems is strictly limited to the non-safety-critical portions of the architecture. Understanding where and how to properly use GtkAda is essential for maintaining system safety.</p>
            
            <h3>Appropriate Use Cases for GtkAda</h3>
            <p>GtkAda should only be used in the following contexts:</p>
            
            <div class="two-column">
                <div class="column">
                    <h4>Acceptable Applications</h4>
                    <ul>
                        <li>Non-safety-critical monitoring displays</li>
                        <li>Configuration tools (not used during operation)</li>
                        <li>Diagnostic interfaces with safety interlocks</li>
                        <li>Training simulators</li>
                        <li>Non-critical data visualization</li>
                    </ul>
                </div>
                <div class="column">
                    <h4>Unacceptable Applications</h4>
                    <ul>
                        <li>Safety-critical control interfaces</li>
                        <li>Direct actuator control</li>
                        <li>Critical parameter entry without validation</li>
                        <li>Systems requiring DAL A/B certification</li>
                        <li>Time-critical operations</li>
                    </ul>
                </div>
            </div>
            
            <h3>GtkAda Implementation Pattern</h3>
            <p>When using GtkAda in safety-critical systems, follow this implementation pattern:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- UI Partition using GtkAda (Level D)
with Gtk.Window; use Gtk.Window;
with Gtk.Button; use Gtk.Button;
with Gtk.Handlers; use Gtk.Handlers;
with Flight_Control; -- Only interface package

package Flight_Display_Gtk is
   
   -- Main window and widgets
   Win : Gtk_Window;
   Altitude_Display : Gtk_Label;
   Emergency_Button : Gtk_Button;
   
   -- Initialize UI (called once at startup)
   procedure Initialize;
   
   -- Update display from safety-critical system
   procedure Update_Display;
   
   -- Callbacks (never directly affect safety logic)
   procedure On_Emergency_Button_Click (Object : access Gtk_Button_Record'Class);
   
private
   -- Safety state cache (never the source of truth)
   Current_Mode : Flight_Control.Flight_Mode := Flight_Control.Normal;
   Current_Altitude : Flight_Control.Altitude := 0.0;
end Flight_Display_Gtk;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">package body Flight_Display_Gtk is
   
   procedure Initialize is
   begin
      Gtk.Window.Initialize (Win);
      Set_Title (Win, "Flight Control Display");
      
      -- Create altitude display
      Gtk.Label.Initialize (Altitude_Display);
      Pack_Start (Win, Altitude_Display, Expand => False);
      
      -- Create emergency button
      Gtk.Button.Initialize (Emergency_Button);
      Set_Label (Emergency_Button, "EMERGENCY");
      Pack_Start (Win, Emergency_Button, Expand => False);
      
      -- Connect callbacks
      On_Clicked (Emergency_Button, On_Emergency_Button_Click'Access);
      
      -- Show main window
      Show_All (Win);
      
      -- Initial display update
      Update_Display;
   end Initialize;
   
   procedure Update_Display is
      Mode : Flight_Control.Flight_Mode;
      Altitude : Flight_Control.Altitude;
   begin
      -- Get state from safety-critical system
      Flight_Control.Get_UI_State (Mode, Altitude);
      
      -- Cache state for display purposes
      Current_Mode := Mode;
      Current_Altitude := Altitude;
      
      -- Update display elements
      Set_Text (Altitude_Display, 
                "Altitude: " & Altitude'Img & " ft");
      
      case Mode is
         when Flight_Control.Normal =>
            Modify_Fg (Altitude_Display, 
                       Gtk.Enums.State_Normal, 
                       Gdk.Color.Red);
            
         when Flight_Control.Emergency =>
            Modify_Fg (Altitude_Display, 
                       Gtk.Enums.State_Normal, 
                       Gdk.Color.Red);
            -- Additional emergency visual cues
      end case;
   end Update_Display;
   
   procedure On_Emergency_Button_Click 
     (Object : access Gtk_Button_Record'Class) is
   begin
      -- NEVER directly affect safety logic
      -- Instead, request action through proper channel
      declare
         Valid : Boolean;
         Target : Flight_Control.Altitude := 0.0;
      begin
         -- Validate input against safety constraints
         Validate_Input (Emergency_Action, Valid, Target);
         
         if Valid then
            -- Only send validated input to safety system
            Flight_Control.Set_Altitude_Target (Target);
         end if;
      end;
   end On_Emergency_Button_Click;
   
end Flight_Display_Gtk;</code></pre>
            </div>
            
            <div class="tip-box">
                <p><strong>Critical Warning:</strong> GtkAda and GTK are <em>not safety-critical components</em> and should never be used in the safety-critical partition of a system. They lack the determinism, verifiability, and certification evidence required for DO-178C Level A/B or IEC 62304 Class C systems. Always maintain strict architectural separation.</p>
            </div>
            
            <div class="note-box">
                <p><strong>Verification Tip:</strong> For the UI partition, focus verification on the interface with the safety-critical components. Ensure all inputs to the safety-critical system are rigorously validated, and that UI errors cannot propagate across the partition boundary.</p>
            </div>
        </div>
    </div>
    
    <hr class="section-divider">
    
    <div class="tutorial-section">
        <h2>Model-View-Controller Patterns for Safety-Critical Systems</h2>
        <div class="section-block">
            <p>The Model-View-Controller (MVC) pattern provides a useful framework for organizing safety-critical HMIs, but requires significant adaptation to meet safety requirements. Traditional MVC implementations often create dangerous coupling between components that must be eliminated in safety-critical contexts.</p>
            
            <h3>Safety-Adapted MVC Architecture</h3>
            
            <p>In safety-critical systems, MVC must incorporate strict separation:</p>
            
            <h3>Safety-Critical Model</h3>
            <ul>
                <li>Resides in safety-critical partition (Level A/B)</li>
                <li>Contains only safety-critical state</li>
                <li>No direct reference to views or controllers</li>
                <li>Provides read-only status interface for views</li>
                <li>Accepts only validated inputs from controllers</li>
            </ul>
            
            <h3>UI-Side Adaptation</h3>
            <ul>
                <li>View: Renders safety status with fail-safe defaults</li>
                <li>Controller: Validates inputs before forwarding</li>
                <li>Communication: One-way with explicit validation</li>
                <li>No callbacks into safety-critical model</li>
                <li>State caching with timeout for stale data</li>
            </ul>
            
            <h3>Implementation Pattern with Safety Constraints</h3>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Safety-Critical Model (Level A/B)
package Flight_Model with SPARK_Mode is
   
   -- Safety-critical state
   type Altitude is delta 0.1 range 0.0 .. 50000.0;
   Current_Altitude : Altitude := 0.0 with Volatile;
   
   -- Safety limits
   Max_Safe_Altitude : constant Altitude := 45000.0;
   Min_Safe_Altitude : constant Altitude := 100.0;
   
   -- Model operations
   procedure Set_Target_Altitude (Target : Altitude) with
      Pre => Target in Min_Safe_Altitude .. Max_Safe_Altitude;
      
   function Get_Current_State return Altitude;
   
   -- Safety-critical status interface for views
   procedure Get_Status_For_View 
     (Altitude : out Altitude;
      IsValid  : out Boolean);
      
private
   Target_Altitude : Altitude := 0.0;
   Last_Update_Time : Ada.Real_Time.Time := Ada.Real_Time.Clock;
end Flight_Model;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- UI-Side View (Level D)
with Flight_Model; -- Interface only
with Gtk.Label; use Gtk.Label;

package Altitude_View is
   
   procedure Initialize (Label : Gtk_Label);
   procedure Update;
   
private
   Display_Label : Gtk_Label;
   Last_Valid_Altitude : Flight_Model.Altitude := 0.0;
   Data_Valid : Boolean := False;
   Last_Update : Ada.Real_Time.Time := Ada.Real_Time.Clock;
   
   Max_Stale_Time : constant Ada.Real_Time.Time_Span := 
      Ada.Real_Time.Milliseconds (2000);
end Altitude_View;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">package body Altitude_View is
   
   procedure Initialize (Label : Gtk_Label) is
   begin
      Display_Label := Label;
      Update;
   end Initialize;
   
   procedure Update is
      Altitude : Flight_Model.Altitude;
      Is_Valid : Boolean;
      Current_Time : constant Ada.Real_Time.Time := Ada.Real_Time.Clock;
   begin
      -- Get status from safety-critical model
      Flight_Model.Get_Status_For_View (Altitude, Is_Valid);
      
      -- Track validity and staleness
      Data_Valid := Is_Valid;
      Last_Valid_Altitude := Altitude;
      Last_Update := Current_Time;
      
      -- Update display with appropriate styling
      if Is_Valid and then
         (Current_Time - Last_Update) < Max_Stale_Time then
         
         Set_Text (Display_Label, 
                   "Altitude: " & Altitude'Img & " ft");
                   
         -- Normal styling
         Modify_Fg (Display_Label, 
                    Gtk.Enums.State_Normal, 
                    Gdk.Color.Black);
      else
         -- Fail-safe display for invalid or stale data
         Set_Text (Display_Label, "ALTITUDE --");
         
         -- Warning styling
         Modify_Fg (Display_Label, 
                    Gtk.Enums.State_Normal, 
                    Gdk.Color.Red);
                    
         -- Additional warning indicators
         Trigger_Visual_Warning;
      end if;
   end Update;
   
end Altitude_View;</code></pre>
            </div>
            
            <h3>Safety-Critical Controller Pattern</h3>
            
            <div class="code-block">
                <pre><code class="language-ada">-- UI-Side Controller (Level D)
with Flight_Model; -- Interface only

package Altitude_Controller is
   
   procedure Handle_Altitude_Input (Input : String);
   
private
   -- Input validation is critical
   function Validate_Altitude 
     (Input : String; 
      Value : out Flight_Model.Altitude) return Boolean;
      
   -- Safety interlocks
   function Is_Change_Safe 
     (Current : Flight_Model.Altitude;
      Target  : Flight_Model.Altitude) return Boolean;
end Altitude_Controller;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">package body Altitude_Controller is
   
   function Validate_Altitude 
     (Input : String; 
      Value : out Flight_Model.Altitude) return Boolean is
      Raw_Value : Integer;
   begin
      -- Parse input (handle errors safely)
      begin
         Raw_Value := Integer'Value (Input);
         Value := Flight_Model.Altitude (Raw_Value);
         return True;
      exception
         when others =>
            return False;
      end;
   end Validate_Altitude;
   
   function Is_Change_Safe 
     (Current : Flight_Model.Altitude;
      Target  : Flight_Model.Altitude) return Boolean is
      Rate_Of_Climb : constant := 
         abs (Target - Current) / Max_Allowed_Rate;
   begin
      -- Safety constraint: gradual altitude changes
      return Rate_Of_Climb <= Max_Safe_Rate;
   end Is_Change_Safe;
   
   procedure Handle_Altitude_Input (Input : String) is
      Valid_Value : Flight_Model.Altitude;
      Is_Valid : Boolean;
      Current_Altitude : Flight_Model.Altitude;
   begin
      -- Step 1: Validate basic input format
      Is_Valid := Validate_Altitude (Input, Valid_Value);
      
      if not Is_Valid then
         Log_Invalid_Input (Input);
         Trigger_Input_Error;
         return;
      end if;
      
      -- Step 2: Get current state for safety check
      Current_Altitude := Flight_Model.Get_Current_State;
      
      -- Step 3: Apply safety interlocks
      if not Is_Change_Safe (Current_Altitude, Valid_Value) then
         Log_Safety_Violation ("Altitude change too rapid");
         Trigger_Safety_Warning;
         return;
      end if;
      
      -- Step 4: Only now forward to safety-critical model
      Flight_Model.Set_Target_Altitude (Valid_Value);
      
   exception
      when others =>
         Log_Exception ("Altitude input handling");
         Trigger_Fallback_Mode;
   end Handle_Altitude_Input;
   
end Altitude_Controller;</code></pre>
            </div>
            
            <div class="note-box">
                <p><strong>Safety-Critical MVC Note:</strong> Unlike traditional MVC, the safety-critical model <em>never</em> has references to views or controllers. All communication is strictly one-way from model to view, and controller inputs must pass through rigorous validation before reaching the model. This eliminates dangerous feedback loops that could compromise safety.</p>
            </div>
        </div>
    </div>
    
    <hr class="section-divider">
    
    <div class="tutorial-section">
        <h2>Safety-Critical UI Design Principles</h2>
        <div class="section-block">
            <p>Beyond architectural considerations, the actual design of the user interface must incorporate specific safety principles. These principles address how information is presented to operators and how inputs are processed to prevent errors.</p>
            
            <h3>Core Safety-Critical UI Principles</h3>
            
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Principle</th>
                        <th>Implementation Guidance</th>
                        <th>Safety Benefit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Fail-Safe Defaults</td>
                        <td>All UI elements default to safe states; no action required for safe operation</td>
                        <td>Prevents accidents from unattended interfaces or missed inputs</td>
                    </tr>
                    <tr>
                        <td>Unambiguous Status</td>
                        <td>Critical states use multiple sensory channels (color, shape, sound)</td>
                        <td>Reduces misinterpretation of system state during high-stress situations</td>
                    </tr>
                    <tr>
                        <td>Input Validation</td>
                        <td>All inputs validated against safety constraints before acceptance</td>
                        <td>Prevents invalid commands from reaching safety-critical components</td>
                    </tr>
                    <tr>
                        <td>Action Confirmation</td>
                        <td>Critical actions require explicit confirmation with safety interlocks</td>
                        <td>Prevents accidental activation of dangerous operations</td>
                    </tr>
                    <tr>
                        <td>Stale Data Handling</td>
                        <td>Automatic timeout for status information; clear indication of stale data</td>
                        <td>Prevents decisions based on outdated system state</td>
                    </tr>
                    <tr>
                        <td>Degraded Mode Support</td>
                        <td>UI adapts to system degradation with simplified, critical-only interface</td>
                        <td>Maintains situational awareness during partial system failures</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Implementing Fail-Safe Defaults</h3>
            <p>Critical UI elements must default to safe states:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Safety-critical display initialization
procedure Initialize_Display is
   Current_Mode : Flight_Model.Flight_Mode;
begin
   -- Get current mode from safety-critical system
   Current_Mode := Flight_Model.Get_Current_Mode;
   
   -- Initialize all displays to safe state
   case Current_Mode is
      when Normal =>
         Set_Display_Mode (Normal_View);
         
      when others =>
         -- Fail-safe default for unknown states
         Set_Display_Mode (Emergency_View);
         Trigger_All_Warnings;
   end case;
   
   -- Initialize all controls to safe positions
   Throttle_Control.Set_Position (Idle_Position);
   Landing_Gear_Switch.Set_Position (Retracted);
   Flaps_Control.Set_Position (0.0);
   
   -- Additional safety checks
   Verify_Display_Integrity;
end Initialize_Display;</code></pre>
            </div>
            
            <h3>Implementing Unambiguous Status Indication</h3>
            <p>Critical status information must use multiple sensory channels:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Emergency status indication
procedure Show_Emergency_Status is
   Current_Time : constant Ada.Real_Time.Time := Ada.Real_Time.Clock;
begin
   -- Visual indication (primary)
   Set_Background_Color (Main_Display, Gdk.Color.Red);
   Set_Text_Style (Warning_Label, Bold);
   Set_Text (Warning_Label, "EMERGENCY: ALTITUDE LOST");
   
   -- Shape indication (secondary)
   Set_Shape (Warning_Icon, Triangle);
   Set_Size (Warning_Icon, Large);
   
   -- Audio indication (tertiary)
   if (Current_Time - Last_Audio_Alert) > Min_Alert_Interval then
      Play_Alert_Sound (Emergency_Tone);
      Last_Audio_Alert := Current_Time;
   end if;
   
   -- Haptic feedback if available
   if Haptic_Feedback_Available then
      Activate_Vibration_Pattern (Emergency_Pattern);
   end if;
end Show_Emergency_Status;</code></pre>
            </div>
            
            <div class="warning-box">
                <p><strong>Critical Design Warning:</strong> Never rely on a single sensory channel for critical status information. In high-stress situations, operators may miss visual or auditory cues. Multiple redundant channels significantly increase the likelihood of proper recognition.</p>
            </div>
            
            <div class="note-box">
                <p><strong>Best Practice:</strong> For IEC 62304 Class C medical devices, implement color-blind friendly designs by combining color with shape and position. Never use color alone to convey critical information.</p>
            </div>
        </div>
    </div>
    
    <hr class="section-divider">
    
    <div class="tutorial-section">
        <h2>Advanced Patterns for Safety-Critical HMIs</h2>
        <div class="section-block">
            <h3>Pattern 1: Formally Verified Interface Contracts</h3>
            <p>Using SPARK to formally verify the communication between UI and safety-critical components.</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Safety-critical interface package (SPARK)
package Safety_Interface with SPARK_Mode is
   
   -- Valid command types
   type Command_Type is (Set_Altitude, Set_Heading, Emergency_Stop);
   
   -- Valid altitude range
   subtype Valid_Altitude is 
      Flight_Model.Altitude range 
         Flight_Model.Min_Safe_Altitude .. 
         Flight_Model.Max_Safe_Altitude;
   
   -- Command record with formal constraints
   type Command_Record (Cmd : Command_Type := Set_Altitude) is record
      case Cmd is
         when Set_Altitude =>
            Altitude : Valid_Altitude;
         when Set_Heading =>
            Heading : Valid_Heading;
         when Emergency_Stop =>
            null;
      end case;
   end record with
      Dynamic_Predicate =>
         (if Cmd = Set_Altitude then 
             Altitude in Valid_Altitude);
   
   -- Interface operations
   procedure Submit_Command (Cmd : Command_Record) with
      Global => (In_Out => Command_Buffer),
      Pre    => not Command_Buffer.Full,
      Post   => Command_Buffer.Size = Command_Buffer.Size'Old + 1;
      
   function Get_Status return System_Status with
      Global => System_State;
      
private
   -- Implementation details hidden from UI
   type Command_Buffer_Type is private;
   Command_Buffer : Command_Buffer_Type;
   
   type System_Status is record
      Altitude : Flight_Model.Altitude;
      Heading  : Flight_Model.Heading;
      Mode     : Flight_Model.Flight_Mode;
      IsValid  : Boolean;
   end record;
   
end Safety_Interface;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">-- UI-side command preparation (SPARK)
with Safety_Interface;

package Command_Preparation with SPARK_Mode is
   
   -- Validate raw input against safety constraints
   function Validate_Input 
     (Raw_Input : String; 
      Cmd       : out Safety_Interface.Command_Record;
      Is_Valid  : out Boolean) return String;
      
   -- Safety interlock checks
   function Check_Safety_Interlocks 
     (Current_Status : Safety_Interface.System_Status;
      Proposed_Cmd   : Safety_Interface.Command_Record) 
      return Boolean;
      
end Command_Preparation;</code></pre>
            </div>
            
            <h4>Safety Benefits:</h4>
            <ul>
                <li>Mathematical proof that only valid commands reach safety-critical components</li>
                <li>Guaranteed preservation of safety invariants across the interface</li>
                <li>Complete verification of input validation logic</li>
                <li>Certification evidence for DO-178C Level A interface requirements</li>
            </ul>
            
            <div class="note-box">
                <p><strong>Certification Evidence:</strong> SPARK proof reports showing 100% verification conditions discharged for the interface package and command preparation logic.</p>
            </div>
            
            <h3>Pattern 2: Fail-Safe Display Degradation</h3>
            <p>Implementing a progressive degradation strategy when display components fail.</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Display degradation management
package Display_Degradation is
   
   type Display_Level is (Full, Reduced, Minimal, Emergency);
   
   -- Initialize degradation monitoring
   procedure Initialize;
   
   -- Update display based on current degradation level
   procedure Update_Display (Level : Display_Level);
   
   -- Check system health for degradation triggers
   procedure Check_Health;
   
   -- Manual override for degradation level
   procedure Set_Degradation_Level (Level : Display_Level);
   
private
   Current_Level : Display_Level := Full;
   Last_Health_Check : Ada.Real_Time.Time := Ada.Real_Time.Clock;
   
   Health_Check_Interval : constant Ada.Real_Time.Time_Span := 
      Ada.Real_Time.Milliseconds (500);
   
   -- Health indicators
   Display_Faults : array (Display_Level) of Boolean := (others => False);
   Critical_System_Faults : Boolean := False;
end Display_Degradation;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">package body Display_Degradation is
   
   procedure Initialize is
   begin
      Current_Level := Full;
      Last_Health_Check := Ada.Real_Time.Clock;
      Reset_Fault_Indicators;
   end Initialize;
   
   procedure Update_Display (Level : Display_Level) is
   begin
      Current_Level := Level;
      
      case Level is
         when Full =>
            Render_Full_Display;
            
         when Reduced =>
            Render_Reduced_Display;
            Activate_Warning ("Display degraded - check system");
            
         when Minimal =>
            Render_Minimal_Display;
            Activate_Warning ("CRITICAL DISPLAY DEGRADATION");
            
         when Emergency =>
            Render_Emergency_Display;
            Activate_Critical_Warning;
      end case;
   end Update_Display;
   
   procedure Check_Health is
      Current_Time : constant Ada.Real_Time.Time := Ada.Real_Time.Clock;
      New_Level : Display_Level := Current_Level;
   begin
      -- Only check health at defined intervals
      if (Current_Time - Last_Health_Check) < Health_Check_Interval then
         return;
      end if;
      
      Last_Health_Check := Current_Time;
      
      -- Check for display subsystem faults
      Update_Fault_Indicators;
      
      -- Determine appropriate degradation level
      if Critical_System_Faults then
         New_Level := Emergency;
      elsif Display_Faults (Minimal) then
         New_Level := Minimal;
      elsif Display_Faults (Reduced) then
         New_Level := Reduced;
      else
         New_Level := Full;
      end if;
      
      -- Only change to more severe degradation
      if Degradation_Level_Severity (New_Level) > 
         Degradation_Level_Severity (Current_Level) then
         Update_Display (New_Level);
      end if;
   end Check_Health;
   
   -- Additional implementation details...
   
end Display_Degradation;</code></pre>
            </div>
            
            <h4>Safety Benefits:</h4>
            <ul>
                <li>Maintains critical information availability during partial failures</li>
                <li>Prevents complete loss of situational awareness</li>
                <li>Provides clear indication of degradation level</li>
                <li>Supports continued safe operation during subsystem failures</li>
            </ul>
            
            <div class="note-box">
                <p><strong>Certification Evidence:</strong> Fault injection test results showing proper degradation behavior, verification of degradation logic, and evidence that critical information remains available at all degradation levels.</p>
            </div>
            
            <h3>Pattern 3: Safety Interlock Verification Framework</h3>
            <p>Implementing a verifiable framework for safety interlocks on user inputs.</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Safety interlock framework
package Safety_Interlocks with SPARK_Mode is
   
   -- Types of safety checks
   type Safety_Check is 
      (Altitude_Rate, Heading_Change, Configuration_Valid);
   
   -- Result of safety check
   type Check_Result is (Pass, Fail, Warning);
   
   -- Safety policy definition
   type Safety_Policy is array (Safety_Check) of Boolean
      with Dynamic_Predicate =>
         Policy (Altitude_Rate) or else
         Policy (Heading_Change) or else
         Policy (Configuration_Valid);
   
   -- Safety context for checks
   type Safety_Context is record
      Current_Altitude : Flight_Model.Altitude;
      Current_Heading  : Flight_Model.Heading;
      Target_Altitude  : Flight_Model.Altitude;
      Target_Heading   : Flight_Model.Heading;
      System_Mode      : Flight_Model.Flight_Mode;
      -- Additional context as needed
   end record;
   
   -- Verify command against safety policy
   function Verify_Command 
     (Context : Safety_Context;
      Policy  : Safety_Policy) return Check_Result with
      Pre => Policy'First <= Altitude_Rate and Policy'Last >= Configuration_Valid;
      
   -- Get reason for failure
   function Failure_Reason return String;
   
private
   Last_Failure : String (1 .. 100) := (others => ' ');
   Last_Failure_Length : Natural := 0;
end Safety_Interlocks;</code></pre>
            </div>
            
            <div class="code-block">
                <pre><code class="language-ada">package body Safety_Interlocks is
   
   function Verify_Command 
     (Context : Safety_Context;
      Policy  : Safety_Policy) return Check_Result is
      
      Result : Check_Result := Pass;
      Temp   : Check_Result;
   begin
      -- Check each enabled safety constraint
      if Policy (Altitude_Rate) then
         Temp := Check_Altitude_Rate (Context);
         if Temp = Fail then
            Set_Failure_Reason ("Altitude change rate violation");
            return Fail;
         elsif Temp = Warning and Result = Pass then
            Result := Warning;
            Set_Failure_Reason ("Caution: Rapid altitude change");
         end if;
      end if;
      
      if Policy (Heading_Change) then
         Temp := Check_Heading_Change (Context);
         if Temp = Fail then
            Set_Failure_Reason ("Heading change violation");
            return Fail;
         elsif Temp = Warning and Result = Pass then
            Result := Warning;
            Set_Failure_Reason ("Caution: Rapid heading change");
         end if;
      end if;
      
      if Policy (Configuration_Valid) then
         Temp := Check_Configuration (Context);
         if Temp = Fail then
            Set_Failure_Reason ("Invalid configuration");
            return Fail;
         end if;
      end if;
      
      return Result;
   end Verify_Command;
   
   -- Implementation of individual checks...
   
   function Check_Altitude_Rate (Context : Safety_Context) return Check_Result is
      Rate : constant := 
         abs (Context.Target_Altitude - Context.Current_Altitude) / Max_Allowed_Time;
   begin
      if Rate > Max_Safe_Rate then
         return Fail;
      elsif Rate > Warning_Threshold then
         return Warning;
      else
         return Pass;
      end if;
   end Check_Altitude_Rate;
   
   -- Additional check implementations...
   
end Safety_Interlocks;</code></pre>
            </div>
            
            <h4>Safety Benefits:</h4>
            <ul>
                <li>Mathematically verified safety constraints on user inputs</li>
                <li>Clear separation between policy and implementation</li>
                <li>Comprehensive failure diagnostics</li>
                <li>Support for multiple safety levels (pass/warning/fail)</li>
            </ul>
            
            <div class="note-box">
                <p><strong>Certification Evidence:</strong> SPARK verification reports, test results for all safety check conditions, and evidence of proper integration with UI input handling.</p>
            </div>
            
            <h3>Pattern Selection Guide:</h3>
            <ul>
                <li><strong>For critical interfaces:</strong> Always use formally verified interface contracts with SPARK. This is essential for DO-178C Level A/B systems.</li>
                <li><strong>For display systems:</strong> Implement fail-safe degradation with at least three levels (full, reduced, emergency) to maintain situational awareness during failures.</li>
                <li><strong>For input handling:</strong> Use the safety interlock framework with clear pass/warning/fail states and detailed failure diagnostics.</li>
                <li><strong>For medical devices:</strong> Add additional checks for IEC 62304 requirements, particularly around user error prevention and fail-safe states.</li>
            </ul>
            
            <div class="tip-box">
                <p><strong>Remember:</strong> The UI is not safety-critical, but its integration with safety-critical components must be designed and verified to safety-critical standards. Focus verification efforts on the interface boundaries.</p>
            </div>
        </div>
    </div>
    
    <hr class="section-divider">
    
    <div class="tutorial-section">
        <h2>Verification of Safety-Critical HMI Components</h2>
        <div class="section-block">
            <p>Verification of safety-critical HMIs requires a specialized approach that focuses on the interface between UI components and safety-critical logic. Unlike conventional GUI testing, safety-critical verification must address architectural boundaries, safety interlocks, and fail-safe behavior.</p>
            
            <h3>Verification Strategy for Safety-Critical HMIs</h3>
            
            <p>A comprehensive verification approach includes:</p>
            
            <h3>Interface Verification</h3>
            <ul>
                <li>Formal verification of interface contracts</li>
                <li>Boundary condition testing</li>
                <li>Invalid input handling verification</li>
                <li>Timing analysis of interface operations</li>
                <li>Traceability from safety requirements</li>
            </ul>
            
            <h3>UI Component Verification</h3>
            <ul>
                <li>Fail-safe behavior testing</li>
                <li>Display degradation validation</li>
                <li>Safety interlock verification</li>
                <li>Stale data handling tests</li>
                <li>Human factors validation</li>
            </ul>
            
            <h3>Formal Verification of Interface Contracts</h3>
            <p>The critical interface between UI and safety-critical components must be formally verified:</p>
            
            <div class="code-block">
                <pre><code class="language-ada">-- Example SPARK verification output
$ gnatprove --level=4 --report=all safety_interface.ads

safety_interface.ads:25:16: info: range check proved
safety_interface.ads:32:22: info: overflow check proved
safety_interface.ads:45:10: info: precondition proved
safety_interface.ads:58:15: info: data dependence proved
safety_interface.ads:62:08: info: flow dependencies proved
safety_interface.ads:71:20: info: dynamic predicate proved

Summary of SPARK analysis
   Flow Constraints:           12 checks passed
   Data Dependencies:          7 checks passed
   Run-Time Errors:            0 errors detected
   Assertions:                 15 checks passed
   Contracts:                  22 checks passed
   Dynamic Predicates:         3 checks passed</code></pre>
            </div>
            
            <h3>Interface Boundary Testing</h3>
            <p>Rigorous testing of the interface boundary is essential:</p>
            
            <h4>Test Categories</h4>
            <ul>
                <li>Valid input boundaries</li>
                <li>Invalid input handling</li>
                <li>Timing behavior</li>
            </ul>
        </div>
    </div>
</div>
