<head>
    <link rel="stylesheet" href="../../css/tutorials.css">
</head>
<div class="tutorial-content">
    <h1 class="tutorial-title">Real-Time Systems Programming in Ada: Timing Guarantees for Critical Applications</h1>
    
    <div class="tutorial-section">
        <p class="tutorial-intro">
            In safety-critical systems, functional correctness is only half the battle - timing correctness is equally vital. Ada provides unique language-level support for real-time programming, allowing developers to specify, verify, and guarantee timing behavior with mathematical precision. This tutorial explores how to leverage Ada's real-time features to build systems that not only do the right thing, but do it at the right time, every time. You'll learn to transform timing requirements from vague aspirations into verifiable system properties.
        </p>
        
        <div class="callout-primary">
            <h4>The Real-Time Challenge</h4>
            <p>
                <strong>Hard real-time:</strong> Missing a deadline is a system failure<br>
                <strong>Firm real-time:</strong> Late results are useless<br>
                <strong>Soft real-time:</strong> Performance degrades gracefully<br>
                Ada provides the tools to meet hard real-time requirements through language features designed specifically for timing-critical applications.
            </p>
        </div>
    </div>
    
    <div class="section-block">
        <h2>Why Most Languages Fail at Real-Time Programming</h2>
        <p>
            General-purpose languages lack the mechanisms to provide timing guarantees, forcing developers to rely on external libraries and platform-specific extensions. This creates fragile systems where:
        </p>
        
        <div class="two-column">
            <div class="column">
                <h3>Common Timing Failures</h3>
                <ul>
                    <li><span class="text-highlight">Unpredictable garbage collection</span> pauses</li>
                    <li><span class="text-highlight">Non-deterministic memory allocation</span></li>
                    <li><span class="text-highlight">Hidden priority inversions</span></li>
                    <li><span class="text-highlight">Unbounded execution times</span></li>
                </ul>
            </div>
            <div class="column">
                <h3>Real-World Consequences</h3>
                <ul>
                    <li>1996: Ariane 5 explosion caused by timing overflow</li>
                    <li>2004: Mars rover Spirit stuck due to priority inversion</li>
                    <li>2010: "Flash crash" partially attributed to timing issues</li>
                    <li>Medical device malfunctions from missed deadlines</li>
                </ul>
            </div>
        </div>
        
        <div class="warning-box">
            <h3>The Ariane 5 Case Study</h3>
            <p>
                The 1996 Ariane 5 rocket explosion was caused by a 64-bit floating point value being converted to a 16-bit integer. But crucially, the error occurred in <em>inertial reference system code that was no longer needed after launch</em>. The system failed because:
            </p>
            <ul>
                <li>There was no way to specify that certain code was only valid during specific phases</li>
                <li>Timing constraints weren't enforced at the language level</li>
                <li>Error handling didn't account for timing context</li>
            </ul>
            <p>
                Ada's real-time features, combined with contracts, would have prevented this by specifying phase-specific validity and timing constraints.
            </p>
        </div>
        
        <div class="definition-box">
            <h4>Ada's Real-Time Philosophy</h4>
            <p>
                Rather than treating timing as an afterthought, Ada integrates real-time capabilities directly into the language with:
            </p>
            <ul>
                <li>Predictable execution semantics</li>
                <li>Language-defined timing primitives</li>
                <li>Compile-time schedulability analysis</li>
                <li>Deadline monitoring built into the runtime</li>
                <li>Formal verification of timing properties</li>
            </ul>
            <p>
                This approach transforms timing from a deployment concern into a design-time verification problem.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Core Real-Time Features in Ada</h2>
        
        <h3>1. Precise Time Representation</h3>
        <p>
            Ada provides a robust time model with nanosecond precision:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">with Ada.Real_Time; use Ada.Real_Time;

procedure Time_Demo is
   Now        : Time := Clock;
   One_Second : Time_Span := Seconds(1);
   Ten_Ms     : Time_Span := Milliseconds(10);
   Five_Us    : Time_Span := Microseconds(5);
begin
   -- Absolute time operations
   Next_Time := Now + One_Second;
   
   -- Relative time operations
   if Delay_Until_Time - Clock >= Ten_Ms then
      Handle_Timing_Violation;
   end if;
   
   -- Time span arithmetic
   Total_Delay := Ten_Ms + Five_Us;
end Time_Demo;</code></pre>
        </div>
        
        <div class="time-model">
            <h3>Key Time Types</h3>
            <ul>
                <li><code class="code-inline">Time</code>: Absolute point in time (since epoch)</li>
                <li><code class="code-inline">Time_Span</code>: Duration between two time points</li>
                <li><code class="code-inline">Clock</code>: Function returning current time</li>
                <li><code class="code-inline">Seconds</code>, <code class="code-inline">Milliseconds</code>, etc.: Duration constructors</li>
            </ul>
            <p>
                Unlike other languages, Ada's time model is part of the language standard, ensuring consistent behavior across platforms.
            </p>
        </div>
        
        <h3>2. Deadline Monitoring</h3>
        <p>
            Specify and verify timing constraints directly in code:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">task Critical_Process is
   pragma Task_Dispatching_Policy (EDF_Within_Priorities);
   pragma Deadline (Seconds => 0.010); -- 10ms deadline
   -- Task definition
end Critical_Process;

task body Critical_Process is
begin
   loop
      -- Work that must complete within deadline
      Process_Data;
      
      -- Optional deadline check
      if Clock - Start_Time > Milliseconds(10) then
         raise Deadline_Missed;
      end if;
   end loop;
exception
   when Deadline_Error =>
      Handle_Deadline_Violation;
end Critical_Process;</code></pre>
        </div>
        
        <div class="scheduling-analysis">
            <h3>Deadline Best Practices</h3>
            <ul>
                <li>Specify deadlines at task declaration for static analysis</li>
                <li>Use runtime checks for critical operations within tasks</li>
                <li>Combine with contracts for complete verification</li>
                <li>Verify worst-case execution time (WCET) through analysis</li>
            </ul>
        </div>
        
        <h3>3. Dispatching Policies</h3>
        <p>
            Control how the runtime schedules tasks:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">-- At the program unit level
pragma Task_Dispatching_Policy (FIFO_Within_Priorities);
-- or
pragma Task_Dispatching_Policy (EDF_Within_Priorities); -- Earliest Deadline First

-- Task-specific priority
task type Sensor_Reader is
   pragma Priority (System.Priority'Last - 10);
   -- Definition
end Sensor_Reader;</code></pre>
        </div>
        
        <div class="two-column">
            <div class="column">
                <h4>Available Policies</h4>
                <ul>
                    <li><code class="code-inline">FIFO_Within_Priorities</code>: Standard priority-based</li>
                    <li><code class="code-inline">EDF_Within_Priorities</code>: Earliest deadline first</li>
                    <li><code class="code-inline">Round_Robin_Within_Priorities</code>: Time-sliced</li>
                </ul>
            </div>
            <div class="column">
                <h4>Policy Selection Guide</h4>
                <ul>
                    <li>Use EDF for systems with strict deadlines</li>
                    <li>Use FIFO for traditional priority-based systems</li>
                    <li>Round robin only for non-critical background tasks</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Real-Time Scheduling Analysis</h2>
        <p>
            One of Ada's most powerful capabilities is enabling schedulability analysis at compile time, rather than through error-prone runtime testing.
        </p>
        
        <h3>Rate Monotonic Analysis (RMA)</h3>
        <p>
            A mathematical approach to verify that all deadlines will be met:
        </p>
        
        <div class="two-column">
            <div class="column">
                <h4>The Math Behind RMA</h4>
                <p>
                    For n periodic tasks, the sufficient condition for schedulability is:
                </p>
                <div class="code-block">
                    <pre>U ≤ n(2^(1/n) - 1)</pre>
                </div>
                <p>
                    Where U is the total CPU utilization:
                </p>
                <div class="code-block">
                    <pre>U = Σ (C_i / T_i)</pre>
                </div>
                <p>
                    C_i = worst-case execution time<br>
                    T_i = task period
                </p>
            </div>
            <div class="column">
                <h4>Ada Implementation</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Task with 10ms period, 2ms WCET
task type Sensor_Task is
   pragma Priority (System.Priority'Last - 5);
   pragma Task_Info (Storage_Size => 4096);
   pragma Time_Handler (Period => Milliseconds(10),
                        WCET    => Microseconds(2000));
end Sensor_Task;</code></pre>
                </div>
                <p>
                    These annotations allow tools like GNATprove to perform formal schedulability analysis.
                </p>
            </div>
        </div>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>WCET Analysis Tools</h3>
                <p>
                    Ada integrates with industry-standard WCET analysis tools:
                </p>
                <ul>
                    <li><strong>aiT</strong>: AbsInt's WCET analyzer</li>
                    <li><strong>Bound-T</strong>: Tidorum's timing analyzer</li>
                    <li><strong>GNATprove</strong>: SPARK-based verification</li>
                    <li><strong>TimeWiz</strong>: Ada-specific timing analysis</li>
                </ul>
                <p>
                    These tools work with Ada's predictable execution model to calculate precise worst-case execution times.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>Schedulability Verification</h3>
                <p>
                    Using SPARK for formal timing verification:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">task type Control_Loop with
   Initializes => (State),
   WCET         => Microseconds(500),
   Period       => Milliseconds(1) is
   entry Start;
   entry Stop;
end Control_Loop with
   Priority => High_Priority,
   Deadline => Milliseconds(1);

-- SPARK can prove:
-- 1. WCET is never exceeded
-- 2. All deadlines are met
-- 3. No priority inversion occurs</code></pre>
                </div>
            </div>
        </div>
        
        <div class="callout-secondary">
            <h4>Practical Schedulability Example: Flight Control System</h4>
            <p>
                Consider a flight control system with these tasks:
            </p>
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Task</th>
                        <th>Period (ms)</th>
                        <th>WCET (ms)</th>
                        <th>Utilization</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Attitude Control</td>
                        <td>1</td>
                        <td>0.3</td>
                        <td>30%</td>
                    </tr>
                    <tr>
                        <td>Navigation Update</td>
                        <td>10</td>
                        <td>1.5</td>
                        <td>15%</td>
                    </tr>
                    <tr>
                        <td>System Monitoring</td>
                        <td>100</td>
                        <td>5.0</td>
                        <td>5%</td>
                    </tr>
                </tbody>
                <tfoot>
                    <tr>
                        <td colspan="3"><strong>Total Utilization:</strong></td>
                        <td><strong>50%</strong></td>
                    </tr>
                </tfoot>
            </table>
            <p>
                With 50% utilization, this system easily meets the RMA bound (69.3% for 3 tasks), guaranteeing all deadlines will be met. Ada's annotations make this analysis automatic.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Temporal Contracts: Specifying Timing Behavior</h2>
        <p>
            Building on Design by Contract, Ada allows specification of temporal properties directly in code - creating what we call "temporal contracts."
        </p>
        
        <h3>Basic Temporal Contracts</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>Deadline Specifications</h4>
                <div class="code-block">
                    <pre><code class="language-ada">procedure Process_Command (
   Cmd : Command_Type;
   Response : out Response_Type) with
   Pre  => Valid_Command(Cmd),
   Post => Valid_Response(Response),
   -- Temporal contract:
   Time_Dependency => Cmd.Timestamp + Milliseconds(50) >= Clock;</code></pre>
                </div>
                <p>
                    Specifies that the command must be processed within 50ms of receipt.
                </p>
            </div>
            
            <div class="column">
                <h4>WCET Specifications</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Calculate_Trajectory (
   Current_State : State;
   Target        : Coordinates) return Trajectory with
   Pre  => Valid_State(Current_State),
   Post => Valid_Trajectory(Result),
   -- Temporal contract:
   WCET => Microseconds(2500);</code></pre>
                </div>
                <p>
                    Specifies a worst-case execution time of 2.5ms for verification.
                </p>
            </div>
        </div>
        
        <h3>Advanced Temporal Patterns</h3>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h4>1. Phase-Based Timing Constraints</h4>
                <p>
                    Different timing requirements for different system phases:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">procedure Process_Flight_Phase (
   Phase : Flight_Phase;
   Data  : Sensor_Data) with
   Pre  => Valid_Phase(Phase),
   Time_Dependency =>
      (case Phase is
         when Launch      => Clock <= T0 + Seconds(180),
         when Ascent      => Clock <= T0 + Seconds(600),
         when Orbit       => Clock <= T0 + Seconds(3600),
         when Descent     => Clock <= T0 + Seconds(7200));</code></pre>
                </div>
            </div>
            
            <div class="feature-card">
                <h4>2. Jitter Constraints</h4>
                <p>
                    Limit variation in execution timing:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">procedure Sample_Sensor (
   Value : out Sensor_Value) with
   Post => Valid_Sensor_Value(Value),
   -- Temporal contract:
   Jitter => Microseconds(50),
   Period => Milliseconds(100);</code></pre>
                </div>
                <p>
                    Ensures samples occur within 50μs of their nominal 100ms interval.
                </p>
            </div>
            
            <div class="feature-card">
                <h4>3. Deadline Chaining</h4>
                <p>
                    Specify timing relationships between operations:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">procedure Process_Command (
   Cmd : Command;
   Response : out Response) with
   Pre  => Valid_Command(Cmd),
   Post => Valid_Response(Response),
   Time_Dependency =>
      (if Cmd.Priority = High then
         Response.Timestamp <= Cmd.Timestamp + Milliseconds(10))
      and
      (if Cmd.Priority = Medium then
         Response.Timestamp <= Cmd.Timestamp + Milliseconds(50));</code></pre>
                </div>
            </div>
        </div>
        
        <div class="temporal-contract">
            <h3>Temporal Contract Verification</h3>
            <p>
                Temporal contracts can be verified at multiple levels:
            </p>
            <div class="two-column">
                <div class="column">
                    <h4>Runtime Verification</h4>
                    <div class="code-block">
                        <pre><code class="language-bash">gnatmake -gnata -D your_program.adb</code></pre>
                    </div>
                    <p>
                        Checks timing contracts during execution
                    </p>
                </div>
                <div class="column">
                    <h4>Static Verification</h4>
                    <div class="code-block">
                        <pre><code class="language-bash">gnatprove --level=2 --report=all your_program.adb</code></pre>
                    </div>
                    <p>
                        Proves timing properties without execution
                    </p>
                </div>
            </div>
            <p>
                For the highest safety levels (DO-178C Level A), both approaches are typically required.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Real-World Real-Time Applications</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Avionics: Flight Control System</h3>
                <p>
                    A safety-critical flight control example:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">with Ada.Real_Time; use Ada.Real_Time;

task type Control_Loop is
   pragma Task_Dispatching_Policy (EDF_Within_Priorities);
   pragma Priority (System.Priority'Last - 5);
   pragma Deadline (Milliseconds(5)); -- 200Hz loop
end Control_Loop;

task body Control_Loop is
   Next_Time : Time := Clock;
   Period    : Time_Span := Milliseconds(5);
begin
   loop
      -- Read sensors (with timing contracts)
      Read_Sensors;
      
      -- Calculate control (with WCET specification)
      Calculate_Control;
      
      -- Apply control (with deadline constraint)
      Apply_Control;
      
      -- Maintain precise timing
      Next_Time := Next_Time + Period;
      delay until Next_Time;
   end loop;
exception
   when Deadline_Error =>
      Switch_To_Fallback_Mode;
end Control_Loop;</code></pre>
                </div>
                <p>
                    This structure guarantees a precisely timed 200Hz control loop.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>Medical Device: Pacemaker Controller</h3>
                <p>
                    Life-critical timing requirements:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">task Pacemaker_Controller is
   pragma Priority (System.Priority'Last);
   pragma Deadline (Milliseconds(100)); -- 10Hz minimum
end Pacemaker_Controller;

task body Pacemaker_Controller is
   Beat_Interval : constant Time_Span := Milliseconds(1000);
   Next_Beat     : Time := Clock;
begin
   loop
      -- Check heart activity
      if Heartbeat_Detected then
         -- Reset timer if natural beat detected
         Next_Beat := Clock + Beat_Interval;
      elsif Clock >= Next_Beat then
         -- Generate electrical pulse
         Generate_Pulse;
         Next_Beat := Next_Beat + Beat_Interval;
      end if;
      
      -- Sleep until next check
      delay until Clock + Milliseconds(10);
   end loop;
end Pacemaker_Controller;</code></pre>
                </div>
                <p>
                    This implementation ensures pacing within 100ms of required intervals.
                </p>
            </div>
        </div>
        
        <div class="callout-primary">
            <h4>DO-178C Certification Requirements</h4>
            <p>
                For avionics software at DAL A (highest criticality), timing must satisfy:
            </p>
            <ul>
                <li>Worst-case execution time analysis</li>
                <li>Verification of all deadline requirements</li>
                <li>Proof of no priority inversion</li>
                <li>Analysis of timing behavior under fault conditions</li>
                <li>Validation through hardware-in-the-loop testing</li>
            </ul>
            <p>
                Ada's integrated real-time features, combined with contracts and SPARK, provide the only practical path to meeting these requirements without prohibitive verification costs.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Advanced Real-Time Patterns</h2>
        
        <div class="real-time-pattern">
            <h3>Pattern 1: Time-Triggered Architecture</h3>
            <p>
                Implement a predictable time-triggered system:
            </p>
            <div class="code-block">
                <pre><code class="language-ada">with Ada.Real_Time; use Ada.Real_Time;

procedure Time_Triggered_System is
   Frame_Duration : constant Time_Span := Milliseconds(10);
   Start_Time     : Time := Clock;
   Current_Frame  : Natural := 0;
begin
   loop
      -- Synchronize to frame boundary
      delay until Start_Time + Frame_Duration * Current_Frame;
      
      -- Frame 0: Sensor reading
      if Current_Frame mod 4 = 0 then
         Read_Sensors;
      end if;
      
      -- Frame 1: Control calculation
      if Current_Frame mod 4 = 1 then
         Calculate_Control;
      end if;
      
      -- Frame 2: Output update
      if Current_Frame mod 4 = 2 then
         Update_Outputs;
      end if;
      
      -- Frame 3: System check
      if Current_Frame mod 4 = 3 then
         Check_System;
      end if;
      
      Current_Frame := (Current_Frame + 1) mod 4;
   end loop;
end Time_Triggered_System;</code></pre>
            </div>
        </div>
        
        <div class="note-box">
            <h3>Why Time-Triggered Architectures Matter</h3>
            <p>
                Time-triggered systems provide deterministic behavior that's easier to verify than event-triggered systems. They're required for many safety-critical applications because:
            </p>
            <ul>
                <li>Predictable timing behavior</li>
                <li>Simpler schedulability analysis</li>
                <li>Easier fault containment</li>
                <li>Reduced testing burden</li>
            </ul>
            <p>
                Ada's precise time model makes implementing time-triggered architectures straightforward and verifiable.
            </p>
        </div>
        
        <div class="real-time-pattern">
            <h3>Pattern 2: Adaptive Deadline Management</h3>
            <p>
                Handle varying workloads while maintaining critical deadlines:
            </p>
            <div class="code-block">
                <pre><code class="language-ada">task Critical_Task is
   pragma Deadline (Milliseconds(10));
end Critical_Task;

task body Critical_Task is
   Base_Deadline : constant Time_Span := Milliseconds(10);
   Current_Deadline : Time_Span := Base_Deadline;
begin
   loop
      -- Monitor system load
      Current_Load := Measure_Load;
      
      -- Adjust deadline based on load
      if Current_Load > 0.8 then
         -- Under heavy load, relax less critical deadlines
         Current_Deadline := Base_Deadline * 1.5;
      else
         Current_Deadline := Base_Deadline;
      end if;
      
      -- Process with current deadline constraint
      Process_Data (Deadline => Current_Deadline);
   end loop;
end Critical_Task;</code></pre>
            </div>
        </div>
        
        <div class="tip-box">
            <h3>WCET-Aware Programming</h3>
            <p>
                Structure code for predictable worst-case execution:
            </p>
            <div class="two-column">
                <div class="column">
                    <h4>Avoid:</h4>
                    <ul>
                        <li>Unbounded loops</li>
                        <li>Dynamic memory allocation</li>
                        <li>Recursion</li>
                        <li>Exceptions in critical paths</li>
                    </ul>
                </div>
                <div class="column">
                    <h4>Prefer:</h4>
                    <ul>
                        <li>Bounded loops with loop invariants</li>
                        <li>Static memory allocation</li>
                        <li>Iteration over recursion</li>
                        <li>Error codes over exceptions</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Exercises: Building Verified Real-Time Systems</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Exercise 1: Automotive Braking System</h3>
                <p>
                    Design a real-time braking controller:
                </p>
                <ul>
                    <li>Implement a 100Hz control loop with WCET constraints</li>
                    <li>Use temporal contracts for all timing requirements</li>
                    <li>Verify schedulability using RMA</li>
                    <li>Implement fault handling with timing guarantees</li>
                    <li>Prove worst-case timing properties with SPARK</li>
                </ul>
                <p>
                    <strong>Challenge:</strong> Prove the system can always apply brakes within 100ms of detecting an obstacle.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>Exercise 2: Industrial Robot Controller</h3>
                <p>
                    Build a robot motion controller with:
                </p>
                <ul>
                    <li>Multiple synchronized control loops</li>
                    <li>Phase-based timing requirements</li>
                    <li>Jitter constraints for smooth motion</li>
                    <li>Deadline chaining for coordinated movement</li>
                    <li>Formal timing verification</li>
                </ul>
                <p>
                    <strong>Challenge:</strong> Prove that all joints move in precise synchronization within 1ms tolerance.
                </p>
            </div>
        </div>
        
        <div class="certification-path">
            <h3>Verification Strategy for Real-Time Systems</h3>
            <ol>
                <li><strong>Design phase:</strong> Specify all timing requirements as temporal contracts</li>
                <li><strong>Implementation:</strong> Structure code for predictable execution</li>
                <li><strong>Static analysis:</strong> Use GNATprove for schedulability analysis</li>
                <li><strong>WCET analysis:</strong> Apply tools like aiT to determine worst-case times</li>
                <li><strong>Runtime verification:</strong> Test with -gnata -D flags</li>
                <li><strong>Hardware validation:</strong> Perform hardware-in-the-loop testing</li>
            </ol>
            <p>
                For the highest safety levels, all six steps are required to demonstrate timing correctness.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Next Steps: Integration and Certification</h2>
        <p>
            Now that you've mastered Ada's real-time capabilities, you're ready to apply these techniques to full system integration and certification. In the next tutorial, we'll explore how to:
        </p>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Upcoming: Certification and Integration</h3>
                <ul>
                    <li>Integrate Ada components with other languages</li>
                    <li>Meet DO-178C and IEC 62304 certification requirements</li>
                    <li>Combine all Ada features for complete system verification</li>
                    <li>Transition from development to certified deployment</li>
                    <li>Build traceability from requirements to code</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3>Practice Challenge</h3>
                <p>
                    Enhance your automotive braking system with certification features:
                </p>
                <ul>
                    <li>Add complete requirements traceability</li>
                    <li>Implement certification artifacts</li>
                    <li>Verify against DO-178C objectives</li>
                    <li>Create a verification matrix</li>
                    <li>Prepare for tool qualification</li>
                </ul>
            </div>
        </div>
        
        <div class="callout-secondary">
            <h4>The Path to Certified Systems</h4>
            <p>
                Real-time programming in Ada represents the culmination of the language's design philosophy: transforming critical system properties from runtime concerns into verifiable design-time guarantees. When combined with strong typing, Design by Contract, and safe concurrency, Ada provides a complete framework for building systems where timing errors are as impossible as type errors.
            </p>
            <p>
                This integrated approach is why Ada remains the language of choice for systems where missing a deadline is not just a bug, but a catastrophic failure. As you complete this tutorial series, you'll see how these techniques combine to create software that's not just functionally correct, but <em>temporally guaranteed</em> within its specified domain.
            </p>
        </div>
    </div>
</div>
