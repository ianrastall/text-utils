<head>
    <link rel="stylesheet" href="../../css/tutorials.css">
</head>
<div class="tutorial-content">
    <h1 class="tutorial-title">Concurrency and Protected Objects in Ada: Safe Parallelism for Critical Systems</h1>
    
    <div class="tutorial-section">
        <p class="tutorial-intro">
            While most programming languages treat concurrency as an afterthought requiring external libraries, Ada integrates safe parallelism directly into the language. This tutorial explores Ada's unique tasking model and protected objects - features designed from the ground up for building reliable concurrent systems where race conditions and deadlocks are prevented at compile time. You'll learn how to structure concurrent applications that maintain correctness guarantees even in the most demanding real-time environments.
        </p>
        
        <div class="callout-primary">
            <h4>Concurrency vs. Parallelism</h4>
            <p>
                <strong>Concurrency</strong>: Managing multiple tasks that make progress independently<br>
                <strong>Parallelism</strong>: Executing multiple tasks simultaneously<br>
                Ada provides language-level support for both, with safety guarantees that prevent the most common concurrency errors.
            </p>
        </div>
    </div>
    
    <div class="section-block">
        <h2>The Concurrency Problem: Why Most Languages Fail</h2>
        <p>
            Concurrency bugs are notoriously difficult to detect and reproduce. Traditional approaches using threads and mutexes create fragile systems where:
        </p>
        
        <div class="two-column">
            <div class="column">
                <h3>Typical Concurrency Issues</h3>
                <ul>
                    <li><span class="text-highlight">Race conditions</span>: Unpredictable behavior from timing dependencies</li>
                    <li><span class="text-highlight">Deadlocks</span>: Circular dependencies causing system freeze</li>
                    <li><span class="text-highlight">Priority inversion</span>: High-priority tasks blocked by low-priority ones</li>
                    <li><span class="text-highlight">Heisenbugs</span>: Errors that disappear when observed</li>
                </ul>
            </div>
            <div class="column">
                <h3>Real-World Consequences</h3>
                <ul>
                    <li>1996: Ariane 5 rocket explosion caused by race condition</li>
                    <li>2003: Northeast blackout from race condition in monitoring software</li>
                    <li>2012: Knight Capital $440M loss from threading error</li>
                    <li>Medical device recalls due to priority inversion</li>
                </ul>
            </div>
        </div>
        
        <div class="warning-box">
            <h3>The Therac-25 Radiation Therapy Machine (Revisited)</h3>
            <p>
                In addition to the contract violations we discussed previously, the Therac-25 failures were compounded by race conditions in the software. The system used shared variables without proper synchronization, allowing dangerous states to occur when specific timing conditions were met. Ada's protected objects would have prevented these race conditions by design.
            </p>
        </div>
        
        <div class="definition-box">
            <h4>Ada's Concurrency Philosophy</h4>
            <p>
                Rather than exposing low-level mechanisms and expecting developers to use them correctly, Ada provides <span class="text-highlight">high-level abstractions with built-in safety</span>. The language enforces correct usage patterns through:
            </p>
            <ul>
                <li>Tasks as first-class language elements</li>
                <li>Protected objects for safe data sharing</li>
                <li>Priority-based scheduling with inheritance</li>
                <li>Deadline monitoring and timing constraints</li>
                <li>Compile-time deadlock detection</li>
            </ul>
            <p>
                This approach shifts error prevention from developer discipline to language enforcement.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Ada Tasks: The Foundation of Concurrency</h2>
        
        <h3>Basic Task Structure</h3>
        <p>
            Tasks are defined as separate program units with their own execution context:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">task Sensor_Reader is
   entry Start;
   entry Stop;
   function Get_Last_Value return Float;
end Sensor_Reader;

task body Sensor_Reader is
   Last_Value : Float := 0.0;
   Running    : Boolean := False;
begin
   loop
      select
         when not Running =>
            accept Start do
               Running := True;
            end Start;
      or
         when Running =>
            accept Stop do
               Running := False;
            end Stop;
      or
         accept Get_Last_Value return Float do
            Get_Last_Value := Last_Value;
         end Get_Last_Value;
      or
         delay 0.1; -- 100ms sampling interval
         if Running then
            Last_Value := Read_Hardware_Sensor;
         end if;
      end select;
      
      exit when Terminated;
   end loop;
end Sensor_Reader;</code></pre>
        </div>
        
        <div class="note-box">
            <h3>Task Select Statement Explained</h3>
            <p>
                The <code class="code-inline">select</code> statement is Ada's powerful mechanism for handling multiple communication possibilities:
            </p>
            <ul>
                <li><code class="code-inline">when</code> clauses specify guards (preconditions) for entries</li>
                <li><code class="code-inline">accept</code> blocks until the entry is called and executes the handler</li>
                <li><code class="code-inline">or</code> separates alternative options</li>
                <li>Time delays can be integrated directly into the selection</li>
            </ul>
            <p>
                This structure prevents race conditions by making communication atomic.
            </p>
        </div>
        
        <h3>Task Communication Patterns</h3>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h4>1. Simple Synchronous Call</h4>
                <div class="code-block">
                    <pre><code class="language-ada">Sensor_Reader.Start;
-- Caller blocks until Start completes</code></pre>
                </div>
                <p>
                    Basic synchronous communication pattern.
                </p>
            </div>
            
            <div class="feature-card">
                <h4>2. Asynchronous Transfer</h4>
                <div class="code-block">
                    <pre><code class="language-ada">Sensor_Reader.Start;
-- Continue immediately without waiting</code></pre>
                </div>
                <p>
                    Use <code class="code-inline">pragma Asynchronous</code> for true fire-and-forget.
                </p>
            </div>
            
            <div class="feature-card">
                <h4>3. Timed Entry Call</h4>
                <div class="code-block">
                    <pre><code class="language-ada">select
   Sensor_Reader.Get_Value(V);
or
   delay 0.5; -- 500ms timeout
   raise Timeout_Error;
end select;</code></pre>
                </div>
                <p>
                    Prevents indefinite blocking with timeout handling.
                </p>
            </div>
            
            <div class="feature-card">
                <h4>4. Conditional Call</h4>
                <div class="code-block">
                    <pre><code class="language-ada">select
   Sensor_Reader.Get_Value(V);
else
   -- Proceed without value
   Handle_Missing_Data;
end select;</code></pre>
                </div>
                <p>
                    Executes alternative if entry isn't immediately available.
                </p>
            </div>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Protected Objects: Safe Shared Data</h2>
        <p>
            While tasks handle active concurrency, protected objects provide safe access to shared data - solving the most common source of concurrency bugs.
        </p>
        
        <h3>Why Protected Objects Beat Mutexes</h3>
        
        <div class="comparison-grid">
            <div class="grid-item">
                <h4>Traditional Mutex Approach</h4>
                <ul>
                    <li>Manual lock/unlock sequence</li>
                    <li>Deadlock-prone (lock ordering issues)</li>
                    <li>No compile-time verification</li>
                    <li>Priority inversion possible</li>
                    <li>Locks often held too long</li>
                </ul>
                <div class="code-block">
                    <pre><code class="language-c">// C code with mutex
pthread_mutex_lock(&amp;mutex);
data = read_sensor();
pthread_mutex_unlock(&amp;mutex);</code></pre>
                </div>
            </div>
            <div class="grid-item">
                <h4>Ada Protected Objects</h4>
                <ul>
                    <li>Automatic lock management</li>
                    <li>Compile-time deadlock detection</li>
                    <li>Priority inheritance built in</li>
                    <li>Entry barriers prevent invalid access</li>
                    <li>Operations defined by contract</li>
                </ul>
                <div class="code-block">
                    <pre><code class="language-ada">protected Sensor_Data is
   entry Read (Value : out Float);
   procedure Write (Value : in Float);
private
   Current_Value : Float := 0.0;
   Valid         : Boolean := False;
end Sensor_Data;</code></pre>
                </div>
            </div>
        </div>
        
        <h3>Protected Object Implementation</h3>
        
        <div class="code-block">
            <pre><code class="language-ada">protected body Sensor_Data is
   entry Read (Value : out Float) when Valid is
   begin
      Value := Current_Value;
   end Read;
   
   procedure Write (Value : in Float) is
   begin
      Current_Value := Value;
      Valid := True;
   end Write;
end Sensor_Data;</code></pre>
        </div>
        
        <div class="two-column">
            <div class="column">
                <h4>Key Elements</h4>
                <ul>
                    <li><code class="code-inline">when</code> clause: Entry barrier (compile-time checked)</li>
                    <li>Automatic mutual exclusion</li>
                    <li>No explicit locks required</li>
                    <li>Priority inheritance prevents inversion</li>
                </ul>
            </div>
            <div class="column">
                <h4>How It Works</h4>
                <ol>
                    <li>Caller attempts entry call</li>
                    <li>Barrier condition evaluated</li>
                    <li>If true, caller gains access</li>
                    <li>If false, caller queued</li>
                    <li>Automatic lock released on exit</li>
                </ol>
            </div>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Advanced Concurrency Patterns</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>1. Priority-Based Scheduling</h3>
                <p>
                    Assign priorities to tasks for deterministic execution:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">task type High_Priority_Task is
   pragma Priority (System.Priority'Last);
   -- Task definition
end High_Priority_Task;</code></pre>
                </div>
                <p>
                    Ada supports priority inheritance to prevent priority inversion:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">pragma Task_Dispatching_Policy (FIFO_Within_Priorities);</code></pre>
                </div>
            </div>
            
            <div class="feature-card">
                <h3>2. Real-Time Deadline Monitoring</h3>
                <p>
                    Ensure tasks meet timing requirements:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">task Mission_Critical_Task is
   pragma Task_Dispatching_Policy (EDF_Within_Priorities);
   pragma Deadline (Seconds => 0.01); -- 10ms deadline
end Mission_Critical_Task;</code></pre>
                </div>
                <p>
                    The runtime monitors deadlines and raises exceptions if missed.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>3. Rendezvous with Parameters</h3>
                <p>
                    Safe data transfer between tasks:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">task Controller is
   entry Receive_Sensor_Data (Value : Float; Timestamp : Time);
end Controller;

task body Controller is
begin
   loop
      accept Receive_Sensor_Data (Value : Float; Timestamp : Time) do
         Process(Value, Timestamp);
      end Receive_Sensor_Data;
   end loop;
end Controller;</code></pre>
                </div>
                <p>
                    Parameters are safely copied during the rendezvous.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>4. Dynamic Task Creation</h3>
                <p>
                    Create tasks at runtime with controlled scope:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">task type Worker is
   -- Definition
end Worker;

type Worker_Access is access Worker;

-- Create dynamically:
W : Worker_Access := new Worker;</code></pre>
                </div>
                <p>
                    Use with caution in safety-critical systems; often better to use task pools.
                </p>
            </div>
        </div>
        
        <div class="callout-secondary">
            <h4>Priority Inversion: The Mars Pathfinder Story</h4>
            <p>
                In 1997, the Mars Pathfinder lander experienced repeated system resets due to priority inversion. A low-priority meteorological task held a mutex needed by a high-priority communications task, but was preempted by medium-priority tasks. This caused the communications task to miss deadlines.
            </p>
            <p>
                Ada's priority inheritance protocol would have automatically elevated the low-priority task's priority while it held the mutex, preventing the inversion. The problem was eventually fixed with a software patch that implemented priority inheritance - a feature built into Ada's protected objects from the start.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Combining Contracts with Concurrency</h2>
        <p>
            One of Ada's most powerful capabilities is applying Design by Contract principles to concurrent systems. This creates verifiable guarantees about concurrent behavior.
        </p>
        
        <h3>Contract Patterns for Tasks</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>Task Interface Contracts</h4>
                <div class="code-block">
                    <pre><code class="language-ada">task Sensor_Reader is
   entry Start with
      Pre => not Is_Running;
      
   entry Stop with
      Pre  => Is_Running,
      Post => not Is_Running;
      
   function Is_Running return Boolean;
end Sensor_Reader;</code></pre>
                </div>
                <p>
                    These contracts ensure valid state transitions for the task interface.
                </p>
            </div>
            
            <div class="column">
                <h4>Protected Object Contracts</h4>
                <div class="code-block">
                    <pre><code class="language-ada">protected Temperature_Monitor with
   Initial_Condition => not Alarm_Active is
   entry Check_Temperature (Temp : Celsius) with
      Pre  => System_Ready,
      Post => (if Temp > Threshold then Alarm_Active);
      
   function Alarm_Status return Boolean;
private
   Alarm_Active : Boolean := False;
end Temperature_Monitor;</code></pre>
                </div>
                <p>
                    Contracts on protected objects ensure data integrity across concurrent accesses.
                </p>
            </div>
        </div>
        
        <div class="tip-box">
            <h3>Verification of Concurrent Properties</h3>
            <p>
                Use SPARK to prove critical concurrent properties:
            </p>
            <div class="code-block">
                <pre><code class="language-ada">protected Flight_Control with
   Initializes => (Pitch, Roll, Yaw),
   Initializes => Control_Locked is
   entry Set_Pitch (Angle : Pitch_Angle) with
      Pre  => not Control_Locked,
      Post => Pitch = Angle;
      
   entry Lock_Controls (Code : Authorization_Code) with
      Pre  => not Control_Locked,
      Post => Control_Locked;
      
private
   Pitch         : Pitch_Angle := 0.0;
   Control_Locked : Boolean := False;
end Flight_Control;</code></pre>
            </div>
            <p>
                With these contracts, SPARK can prove that controls cannot be modified when locked.
            </p>
        </div>
        
        <div class="warning-box">
            <h3>Common Concurrency Pitfalls and Solutions</h3>
            <div class="two-column">
                <div class="column">
                    <h4>Pitfall: Deadlock from Circular Dependencies</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">-- Task A
accept Resource_B;
accept Resource_A;

-- Task B
accept Resource_A;
accept Resource_B;</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h4>Solution: Resource Ordering Protocol</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">-- Always acquire in same order
-- Task A and B both:
accept Resource_A;
accept Resource_B;</code></pre>
                    </div>
                    <p>
                        Ada's compile-time checks can detect potential deadlocks when resource ordering is violated.
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Real-World Concurrency Applications</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Avionics System: Flight Control</h3>
                <p>
                    A multi-sensor flight control system:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">protected Flight_Data is
   entry Set_Attitude (Pitch, Roll, Yaw : Degrees) with
      Pre => System_Available;
      
   function Get_Attitude return Attitude_Data with
      Post => Get_Attitude.Valid;
      
private
   Current_Attitude : Attitude_Data := (Valid => False, others => 0.0);
end Flight_Data;

task Attitude_Sensor is
   pragma Priority (High_Priority);
end Attitude_Sensor;

task Flight_Computer with
   Priority => Highest_Priority,
   Deadline   => 0.01; -- 10ms deadline
-- Processing logic</code></pre>
                </div>
                <p>
                    This structure ensures safe data sharing between sensors and control systems.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>Medical Device: Patient Monitoring</h3>
                <p>
                    Critical patient monitoring system:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">protected Patient_Vitals is
   entry Record_Heart_Rate (BPM : Positive) with
      Pre  => BPM <= 300,
      Post => Heart_Rate = BPM;
      
   entry Record_Blood_Pressure (Systolic, Diastolic : Pressure) with
      Pre  => Systolic > Diastolic and Systolic <= 300;
      
   function Is_Stable return Boolean with
      Post => (if Is_Stable'Result then 
               Heart_Rate in 60..100 and 
               Systolic in 90..120);
      
private
   Heart_Rate  : Positive := 75;
   Systolic    : Pressure := 120;
   Diastolic   : Pressure := 80;
end Patient_Vitals;</code></pre>
                </div>
                <p>
                    Contracts ensure data validity while protected objects prevent race conditions.
                </p>
            </div>
        </div>
        
        <div class="callout-primary">
            <h4>DO-178C Certification Requirements</h4>
            <p>
                For avionics software at DAL A (highest criticality), concurrency must satisfy:
            </p>
            <ul>
                <li>Deterministic task scheduling</li>
                <li>Guaranteed worst-case execution time</li>
                <li>Proven absence of deadlocks</li>
                <li>Verified priority inversion handling</li>
                <li>Formal specification of all shared data</li>
            </ul>
            <p>
                Ada's built-in concurrency features, combined with contracts and SPARK, provide the only practical path to meeting these requirements without prohibitive verification costs.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Exercises: Building Safe Concurrent Systems</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Exercise 1: Air Traffic Control Simulator</h3>
                <p>
                    Design a concurrent air traffic control system:
                </p>
                <ul>
                    <li>Create tasks for radar sensors with different update rates</li>
                    <li>Implement protected objects for aircraft data</li>
                    <li>Add contracts to ensure safe separation distances</li>
                    <li>Set appropriate priorities for critical operations</li>
                    <li>Verify absence of deadlocks with SPARK</li>
                </ul>
                <p>
                    <strong>Challenge:</strong> Prove that two aircraft cannot occupy the same airspace.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>Exercise 2: Nuclear Reactor Monitoring</h3>
                <p>
                    Build a reactor monitoring system with:
                </p>
                <ul>
                    <li>Multiple sensor tasks with different priorities</li>
                    <li>Protected objects for shared reactor state</li>
                    <li>Deadline monitoring for safety-critical readings</li>
                    <li>Contracts ensuring valid state transitions</li>
                    <li>Formal verification of safety properties</li>
                </ul>
                <p>
                    <strong>Challenge:</strong> Prove that emergency shutdown can always proceed regardless of system load.
                </p>
            </div>
        </div>
        
        <div class="note-box">
            <h3>Verification Strategy for Concurrent Systems</h3>
            <ol>
                <li>Start with runtime checking (<code class="code-inline">-gnata</code>) to catch basic errors</li>
                <li>Add contracts to all task interfaces and protected objects</li>
                <li>Use <code class="code-inline">gnatprove --level=1</code> for basic verification</li>
                <li>For critical systems, transition to SPARK subset</li>
                <li>Focus verification efforts on shared data and state transitions</li>
                <li>Test timing properties with real hardware</li>
            </ol>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Next Steps: Real-Time Systems Programming</h2>
        <p>
            Now that you've mastered Ada's concurrency model, you're ready to apply these techniques to real-time systems where timing guarantees are as critical as functional correctness. In the next tutorial, we'll explore how to:
        </p>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Upcoming: Real-Time Systems in Ada</h3>
                <ul>
                    <li>Implement precise timing constraints</li>
                    <li>Use Ada's real-time dispatching policies</li>
                    <li>Verify worst-case execution times</li>
                    <li>Combine contracts with timing requirements</li>
                    <li>Build systems that meet DO-178C and IEC 62304 requirements</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3>Practice Challenge</h3>
                <p>
                    Enhance your air traffic control system with real-time features:
                </p>
                <ul>
                    <li>Add deadlines to all critical operations</li>
                    <li>Implement rate-monotonic scheduling</li>
                    <li>Verify timing properties with SPARK</li>
                    <li>Add temporal contracts to your specifications</li>
                    <li>Test under simulated high-load conditions</li>
                </ul>
            </div>
        </div>
        
        <div class="callout-secondary">
            <h4>The Power of Integrated Concurrency</h4>
            <p>
                Ada's approach to concurrency represents a fundamental shift from how most languages handle parallelism. Rather than exposing low-level mechanisms that are easy to misuse, Ada provides high-level abstractions with built-in safety. This transforms concurrency from a source of bugs into a reliable engineering tool.
            </p>
            <p>
                When combined with strong typing and Design by Contract, Ada's concurrency model enables the development of systems that are not just concurrent, but <em>provably correct</em> in their parallel behavior. This is why Ada remains the language of choice for systems where timing errors can have catastrophic consequences.
            </p>
        </div>
    </div>
</div>
