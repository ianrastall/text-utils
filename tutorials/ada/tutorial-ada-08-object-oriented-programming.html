<div class="tutorial-content">
    <h1 class="tutorial-title">Object-Oriented Programming in Ada: Safety-Critical Polymorphism</h1>
    <div class="tutorial-section">
        <p class="tutorial-intro">
            While many consider object-oriented programming (OOP) inherently risky for safety-critical systems, Ada transforms polymorphism from a source of fragility into a verifiable design tool. This tutorial explores Ada's unique approach to OOP that maintains the benefits of polymorphism while eliminating its traditional risks. You'll learn how Ada's type-safe dispatching, controlled inheritance, and formal verification capabilities enable the development of flexible yet provably correct systems—proving that object-orientation and safety-critical reliability can coexist.
        </p>
        <div class="callout-primary">
            <h4>OOP Safety Paradox</h4>
            <p>
                <strong>Traditional view:</strong> "OOP introduces hidden control flow that's impossible to verify"<br>
                <strong>Ada approach:</strong> "OOP can be made predictable and verifiable through careful language design"<br>
                Ada demonstrates that polymorphism isn't the problem—it's how most languages implement it that creates risks for safety-critical systems.
            </p>
        </div>
    </div>
    
    <div class="section-block">
        <h2>Why Traditional OOP Fails in Safety-Critical Systems</h2>
        <p>
            Conventional object-oriented approaches often introduce unacceptable risks in safety-critical contexts. Understanding these pitfalls is essential to appreciating Ada's safer alternative.
        </p>
        <div class="two-column">
            <div class="column">
                <h3>Common OOP Safety Issues</h3>
                <ul>
                    <li><span class="text-highlight">Unbounded dynamic dispatch</span> creating unpredictable execution paths</li>
                    <li><span class="text-highlight">Hidden inheritance hierarchies</span> that complicate verification</li>
                    <li><span class="text-highlight">Fragile base class problem</span> where changes break derived classes</li>
                    <li><span class="text-highlight">Memory safety issues</span> with improper casting</li>
                    <li><span class="text-highlight">Lack of formal verification</span> for polymorphic behavior</li>
                </ul>
            </div>
            <div class="column">
                <h3>Real-World Consequences</h3>
                <ul>
                    <li>Therac-25 radiation therapy machine failures partly due to OOP issues</li>
                    <li>NASA Mars rover software resets from unexpected dispatching</li>
                    <li>Medical device recalls due to polymorphism-related bugs</li>
                    <li>Avionics system failures from incorrect type casting</li>
                </ul>
            </div>
        </div>
        <div class="warning-box">
            <h4>The Therac-25 Revisited: An OOP Perspective</h4>
            <p>
                The Therac-25 radiation therapy machine failures were exacerbated by object-oriented design issues:
            </p>
            <ul>
                <li>Improper inheritance relationships between operational modes</li>
                <li>Hidden dynamic dispatch causing unexpected behavior</li>
                <li>Lack of verification for polymorphic operations</li>
                <li>Unsafe type casting bypassing safety checks</li>
            </ul>
            <p>
                Ada's type-safe OOP model would have prevented these issues by making polymorphic behavior explicit, verifiable, and constrained.
            </p>
        </div>
    </div>
        <div class="definition-box">
            <h4>Ada's OOP Philosophy</h4>
            <p>
                Rather than adopting OOP wholesale, Ada integrates object-orientation with safety in mind:
            </p>
            <ul>
                <li><span class="text-highlight">Explicit dispatching</span>: No hidden virtual calls</li>
                <li><span class="text-highlight">Controlled inheritance</span>: No fragile base class problem</li>
                <li><span class="text-highlight">Type-safe polymorphism</span>: No unsafe casting</li>
                <li><span class="text-highlight">Verifiable behavior</span>: Dispatching amenable to formal methods</li>
                <li><span class="text-highlight">Gradual adoption</span>: OOP only where it provides clear value</li>
            </ul>
            <p>
                This measured approach transforms polymorphism from a verification challenge into a design asset for safety-critical systems.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Tagged Types: The Foundation of Ada OOP</h2>
        <p>
            Ada's object-orientation centers on tagged types - a safer alternative to traditional class-based inheritance.
        </p>
        
        <h3>Tagged Type Fundamentals</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>Basic Tagged Type Declaration</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Base type declaration
type Sensor is tagged record
   ID      : Sensor_ID;
   Status  : Status_Type;
   Value   : Float;
end record;

-- Derived type declaration
type Temperature_Sensor is new Sensor with record
   Units   : Temperature_Units;
   Min_Val : Float;
   Max_Val : Float;
end record;

type Pressure_Sensor is new Sensor with record
   Min_Pressure : Float;
   Max_Pressure : Float;
end record;</code></pre>
                </div>
            </div>
            <div class="column">
                <h4>Dispatching Operation Declaration</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Dispatching operation (virtual method)
function Get_Value (S : Sensor) return Float is
   (S.Value);

-- Overriding for derived type
function Get_Value (T : Temperature_Sensor) return Float is
   (case T.Units is
      when Celsius    => T.Value,
      when Fahrenheit => (T.Value * 9.0/5.0) + 32.0);

-- Usage with dynamic dispatch
procedure Process (S : Sensor'Class) is
begin
   -- Dispatches to appropriate Get_Value
   Put_Line ("Value: " &amp; Get_Value(S)'Image);
end Process;</code></pre>
                </div>
            </div>
        </div>
        
        <div class="note-box">
            <h3>Key Tagged Type Properties</h3>
            <ul>
                <li><code class="code-inline">tagged</code> keyword enables dispatching behavior</li>
                <li>Record extension for inheritance (no separate class syntax)</li>
                <li>Operations can be dispatching (virtual) or non-dispatching</li>
                <li>Dynamic type accessible via <code class="code-inline">'Tag</code> attribute</li>
                <li>Runtime tag check with <code class="code-inline">in</code> operator</li>
            </ul>
            <p>
                Unlike traditional OOP, Ada makes dispatching explicit rather than implicit, supporting verification.
            </p>
        </div>
        
        <h3>Dispatching Mechanics and Safety</h3>
        <p>
            Understanding Ada's dispatching behavior is critical for safety-critical applications:
        </p>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Dispatching Rules</h4>
                <ul>
                    <li>Dispatching occurs only on <code class="code-inline">tagged</code> type parameters</li>
                    <li>Explicit <code class="code-inline">Sensor'Class</code> needed for polymorphism</li>
                    <li>No implicit dispatching (all virtual calls are explicit)</li>
                    <li>Dispatching only on the first parameter by default</li>
                    <li>Dispatching tables are static and predictable</li>
                </ul>
                <p>
                    This explicitness enables verification of dispatching behavior.
                </p>
            </div>
            
            <div class="feature-card">
                <h4>Runtime Tag Checks</h4>
                <div class="code-block">
                    <pre><code class="language-ada">procedure Process_Sensor (S : Sensor'Class) is
begin
   if S in Temperature_Sensor then
      -- Safe conversion with tag check
      T : Temperature_Sensor := Temperature_Sensor(S);
      -- Work with temperature sensor
      null;
   elsif S in Pressure_Sensor then
      -- Safe conversion with tag check
      P : Pressure_Sensor := Pressure_Sensor(S);
      -- Work with pressure sensor
      null;
   else
      raise Unknown_Sensor_Type;
   end if;
end Process_Sensor;</code></pre>
                </div>
                <p>
                    Ada automatically inserts runtime tag checks during type conversions.
                </p>
            </div>
        </div>
        
        <div class="tip-box">
            <h3>Tagged Type Best Practices</h3>
            <ul>
                <li>Use <code class="code-inline">tagged</code> only when polymorphism is truly needed</li>
                <li>Prefer non-dispatching operations when possible</li>
                <li>Use <code class="code-inline">in</code> operator for safe type checks</li>
                <li>Never disable tag checks in safety-critical code</li>
                <li>Document dispatching behavior in contracts</li>
            </ul>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Advanced Dispatching Operations</h2>
        <p>
            Ada provides precise control over dispatching behavior with features designed specifically for safety-critical applications.
        </p>
        
        <h3>Dispatching on Multiple Parameters</h3>
        <p>
            While traditional OOP only dispatches on the implicit <code>this</code> parameter, Ada supports dispatching on multiple parameters:
        </p>
        
        <div class="two-column">
            <div class="column">
                <h4>Traditional Single Dispatch</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Dispatches only on S parameter
function Process (S : Sensor'Class; 
                 C : Command) return Response is...</code></pre>
                </div>
                <p>
                    Only <code class="code-inline">S</code> determines which implementation is called.
                </p>
            </div>
            <div class="column">
                <h4>Ada Multi-Parameter Dispatching</h4>
                <div class="code-block">
                    <pre><code class="language-ada">function Process (
   S : Sensor'Class; 
   C : Command'Class) return Response is
   pragma Dispatching_Policy (Prefer_Highest);
   -- Implementation
begin
   -- Dispatches based on both S and C types
   -- ...
end Process;</code></pre>
                </div>
                <p>
                    Both parameters contribute to the dispatching decision.
                </p>
            </div>
        </div>
        
        <h3>Dispatching Policy Control</h3>
        <p>
            Ada allows specification of dispatching behavior:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">-- At program unit level
pragma Dispatching_Policy (EDF); -- Earliest Deadline First

-- For specific operations
function Process_Alarm (
   A : Alarm'Class;
   H : Handler'Class) return Response is
   pragma Dispatching_Policy (FIFO_Within_Priorities);
begin
   -- Implementation
end Process_Alarm;

-- For specific types
type Sensor_Dispatcher is tagged record
   -- ...
end record;
pragma Dispatching_Domain (EDF, Sensor_Dispatcher);</code></pre>
        </div>
        
        <div class="callout-secondary">
            <h4>Dispatching Policy Options</h4>
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Policy</th>
                        <th>Behavior</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>FIFO_Within_Priorities</td>
                        <td>Standard priority-based dispatching</td>
                        <td>Most safety-critical applications</td>
                    </tr>
                    <tr>
                        <td>EDF_Within_Priorities</td>
                        <td>Earliest deadline first dispatching</td>
                        <td>Real-time systems with strict deadlines</td>
                    </tr>
                    <tr>
                        <td>Round_Robin_Within_Priorities</td>
                        <td>Time-sliced dispatching</td>
                        <td>Non-critical background tasks</td>
                    </tr>
                    <tr>
                        <td>Prefer_Highest</td>
                        <td>Multi-parameter dispatching policy</td>
                        <td>Operations with multiple class parameters</td>
                    </tr>
                </tbody>
            </table>
            <p>
                These policies make dispatching behavior predictable and verifiable - essential for safety-critical systems.
            </p>
        </div>
        
        <h3>Dispatching with Contracts</h3>
        <p>
            Combining Design by Contract with dispatching operations:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">-- Base type operation with contracts
function Validate (S : Sensor; Value : Float) return Boolean with
   Pre  => Value'Valid,
   Post => Validate'Result = (Value in S.Min_Value..S.Max_Value);

-- Overriding with refined contracts
function Validate (
   T : Temperature_Sensor; 
   Value : Float) return Boolean with
   Pre  => Value'Valid and T.Units = Celsius,
   Post => Validate'Result = 
           (Value in T.Min_Val..T.Max_Val and
            Value in VALID_TEMPERATURE_RANGE),
   -- Refinement of base contract
   Refined_Post => Validate'Result = 
                  (Validate'Result and T.Units = Celsius);

-- Dispatching call with contract verification
procedure Process_Value (
   S : Sensor'Class;
   Value : Float) is
begin
   if Validate(S, Value) then
      -- Safe to use value
      null;
   end if;
end Process_Value;</code></pre>
        </div>
        
        <div class="warning-box">
            <h3>Dispatching Contract Rules</h3>
            <div class="two-column">
                <div class="column">
                    <h4>Precondition Refinement</h4>
                    <ul>
                        <li>Derived type preconditions must be <em>weaker</em> than base type</li>
                        <li>Derived type can accept more inputs than base type</li>
                        <li>Formally: <code class="code-inline">Base_Pre ⇒ Derived_Pre</code></li>
                    </ul>
                </div>
                <div class="column">
                    <h4>Postcondition Refinement</h4>
                    <ul>
                        <li>Derived type postconditions must be <em>stronger</em> than base type</li>
                        <li>Derived type must guarantee more than base type</li>
                        <li>Formally: <code class="code-inline">Derived_Post ⇒ Base_Post</code></li>
                    </ul>
                </div>
            </div>
            <p>
                These Liskov substitution principle rules ensure safe polymorphic behavior and are verified by SPARK.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Interface Types and Controlled Inheritance</h2>
        <p>
            Ada provides sophisticated mechanisms for interface-based programming and controlled inheritance - avoiding many traditional OOP pitfalls.
        </p>
        
        <h3>Abstract Types and Interface Types</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>Abstract Tagged Types</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Abstract base type
type Sensor is abstract tagged record
   ID     : Sensor_ID;
   Status : Status_Type;
end record;

-- Abstract operation (must be overridden)
function Get_Value (S : Sensor) return Float is abstract;

-- Concrete derived type
type Temperature_Sensor is new Sensor with record
   Units : Temperature_Units;
end record;

-- Required override
function Get_Value (T : Temperature_Sensor) return Float is
   (T.Current_Value);</code></pre>
                </div>
                <p>
                    Ensures all derived types implement required operations.
                </p>
            </div>
            <div class="column">
                <h4>Interface Types (Multiple Inheritance)</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Interface declaration
type Measurable is interface;
function Get_Value (M : Measurable) return Float is abstract;

type Calibratable is interface;
procedure Calibrate (C : in out Calibratable) is abstract;

-- Type implementing multiple interfaces
type Sensor is abstract new Measurable and Calibratable with null record;

-- Concrete implementation
type Temperature_Sensor is new Sensor with record
   -- ...
end record;

function Get_Value (T : Temperature_Sensor) return Float is
   (T.Current_Value);

procedure Calibrate (T : in out Temperature_Sensor) is
   -- Implementation
begin
   null;
end Calibrate;</code></pre>
                </div>
                <p>
                    Enables safe multiple inheritance through interface types.
                </p>
            </div>
        </div>
        
        <div class="note-box">
            <h3>Interface-Based Design Benefits</h3>
            <ul>
                <li>Decouples specification from implementation</li>
                <li>Enables true polymorphism without inheritance</li>
                <li>Supports multiple inheritance safely</li>
                <li>Reduces coupling between components</li>
                <li>Improves testability through interface mocking</li>
            </ul>
            <p>
                Interface-based design is particularly valuable in safety-critical systems where dependencies must be strictly controlled.
            </p>
        </div>
        
        <h3>Controlled Inheritance Patterns</h3>
        <p>
            Ada provides mechanisms to control inheritance for safety:
        </p>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h4>1. Sealed Types</h4>
                <p>
                    Prevent further derivation of a type:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">type Final_Sensor is new Sensor with private;
pragma Final_Type(Final_Sensor);

package body Final_Sensor is
   -- Implementation
   -- Cannot be further derived
end Final_Sensor;</code></pre>
                </div>
                <p>
                    Used for types where additional derivation could compromise safety.
                </p>
            </div>
            
            <div class="feature-card">
                <h4>2. Limited Private Types</h4>
                <p>
                    Control access to type internals:
                </p><div class="code-block">
                    <pre><code class="language-ada">package Sensors is
   type Sensor is abstract tagged limited private;
   
   -- Only operations in this package can modify the type
   function Get_ID (S : Sensor) return Sensor_ID;
   procedure Set_Status (S : in out Sensor; Status : Status_Type);
   
private
   type Sensor is abstract tagged record
      ID     : Sensor_ID;
      Status : Status_Type;
   end record;
end Sensors;</code></pre>
                </div>
                <p>
                    Prevents unsafe modifications from outside the package.
                </p>
            </div>
            
            <div class="feature-card">
                <h4>3. Controlled Extension</h4>
                <p>
                    Limit what can be added in derived types:
                </p><div class="code-block">
                    <pre><code class="language-ada">type Base_Type is tagged record
   -- ...
end record;

-- Only these components can be extended
type Extension_Point is tagged private;

-- Derived types must use the extension point
type Derived_Type is new Base_Type and Extension_Point with record
   -- Additional components
end record;

-- Extension point controls what can be added
private
type Extension_Point is tagged record
   -- Controlled extension components
   Safety_Flags : Safety_Masks;
end record;</code></pre>
                </div>
                <p>
                    Ensures derived types maintain safety properties.
                </p>
            </div>
        </div>
        
        <div class="tip-box">
            <h3>Inheritance Safety Guidelines</h3>
            <ol>
                <li>Prefer composition over inheritance when possible</li>
                <li>Use abstract types to define clear interfaces</li>
                <li>Seal types that shouldn't be further derived</li>
                <li>Document inheritance contracts precisely</li>
                <li>Verify Liskov substitution principle compliance</li>
                <li>Use interface types for multiple inheritance needs</li>
            </ol>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Dynamic Binding with Safety Guarantees</h2>
        <p>
            Ada's approach to dynamic binding provides the flexibility of polymorphism with the safety guarantees required for critical systems.
        </p>
        
        <h3>Safe Dynamic Binding Patterns</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>1. Controlled Downcasting</h4>
                <p>
                    Safe conversion between related types:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">procedure Process (S : Sensor'Class) is
begin
   -- Safe conversion with tag check
   if S in Temperature_Sensor then
      T : Temperature_Sensor := Temperature_Sensor(S);
      -- Work with T
      null;
   else
      raise Invalid_Sensor_Type;
   end if;
end Process;

-- Contract ensures safe downcasting
procedure Process (S : Sensor'Class) with
   Pre  => S in Temperature_Sensor,
   Post => True;</code></pre>
                </div>
            </div>
            <div class="column">
                <h4>2. Factory Pattern with Verification</h4>
                <p>
                    Safe creation of polymorphic objects:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">function Create_Sensor (
   Kind : Sensor_Kind;
   ID   : Sensor_ID) return Sensor'Class with
   Post => 
      (if Create_Sensor'Result in Temperature_Sensor then
         Kind = Temperature_Sensor_Kind) and
      (if Create_Sensor'Result in Pressure_Sensor then
         Kind = Pressure_Sensor_Kind) is
begin
   case Kind is
      when Temperature_Sensor_Kind =>
         return Temperature_Sensor'(ID => ID, others => <>);
      when Pressure_Sensor_Kind =>
         return Pressure_Sensor'(ID => ID, others => <>);
      when others =>
         raise Invalid_Sensor_Kind;
   end case;
end Create_Sensor;</code></pre>
                </div>
            </div>
        </div>
        
        <h3>Verification of Dynamic Binding</h3>
        <p>
            Ada enables formal verification of polymorphic behavior:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">-- Base type with verification conditions
type Sensor is abstract tagged record
   ID : Sensor_ID;
end record with
   Type_Invariant => ID /= 0;

-- Dispatching operation with verification
function Validate (S : Sensor; Value : Float) return Boolean with
   Pre  => Value'Valid,
   Post => Validate'Result = (Value in MIN_VALUE..MAX_VALUE),
   Refined_Post => Validate'Result = 
                  (Validate'Result and S.ID /= 0);

-- Verification that derived type satisfies contracts
function Validate (
   T : Temperature_Sensor; 
   Value : Float) return Boolean with
   Pre  => Value'Valid and T.Units = Celsius,
   Post => Validate'Result = 
           (Value in T.Min_Val..T.Max_Val),
   -- Proof that refined postcondition holds
   Refined_Post => 
      (Validate'Result and T.ID /= 0 and T.Units = Celsius);

-- SPARK can prove:
-- 1. All derived types satisfy base contracts
-- 2. Dispatching preserves invariants
-- 3. No unsafe downcasts occur
-- 4. Polymorphic operations maintain safety</code></pre>
        </div>
        
        <div class="callout-primary">
            <h4>DO-178C Considerations for Polymorphism</h4>
            <p>
                For avionics software at DAL A, polymorphism must address:
            </p>
            <ul>
                <li><strong>Dispatching verification:</strong> Proof of correct dispatching behavior</li>
                <li><strong>Type safety:</strong> Verification of all type conversions</li>
                <li><strong>Contract refinement:</strong> Proof of Liskov substitution principle</li>
                <li><strong>State preservation:</strong> Verification of invariants across dispatching</li>
                <li><strong>Traceability:</strong> Mapping from requirements to polymorphic behavior</li>
            </ul>
            <p>
                Ada's type-safe polymorphism, combined with SPARK, provides the only practical approach to meeting these requirements without prohibitive verification costs.
            </p>
        </div>
        
        <div class="warning-box">
            <h3>Common Polymorphism Pitfalls and Solutions</h3>
            <div class="two-column">
                <div class="column">
                    <h4>Pitfall: Unsafe Downcasting</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">-- Dangerous pattern
T : Temperature_Sensor := Temperature_Sensor(S); 
-- No tag check!</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h4>Solution: Verified Downcasting</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">-- Safe pattern with verification
pragma Assert (S in Temperature_Sensor);
T : Temperature_Sensor := Temperature_Sensor(S);</code></pre>
                    </div>
                </div>
            </div>
            <div class="two-column">
                <div class="column">
                    <h4>Pitfall: Unverified Contract Refinement</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">-- Derived precondition stronger than base
Pre => Value > 0.0;  -- Base: Pre => Value'Valid</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h4>Solution: Verified Refinement</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">-- Correct refinement
Pre => Value'Valid;  -- Base precondition
-- Derived can only weaken, not strengthen</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Safety-Critical OOP Patterns</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>1. State Pattern for Safe State Machines</h3>
                <p>
                    Implement state machines with polymorphism:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">-- State interface
type System_State is abstract tagged null record;
procedure Handle_Event (
   S : in out System_State; 
   E : Event_Type) is abstract;

-- Concrete states
type Idle_State is new System_State with null record;
procedure Handle_Event (
   S : in out Idle_State; 
   E : Event_Type) is
begin
   case E is
      when Start => 
         Set_State(Running_State);
      when others =>
         null;
   end case;
end Handle_Event;

type Running_State is new System_State with null record;
procedure Handle_Event (
   S : in out Running_State; 
   E : Event_Type) is
begin
   case E is
      when Stop => 
         Set_State(Idle_State);
      when Emergency =>
         Set_State(Emergency_State);
      when others =>
         null;
   end case;
end Handle_Event;

-- Context using the pattern
type System_Context is tagged record
   Current_State : System_State'Class := Idle_State;
end record;

procedure Handle_System_Event (
   C : in out System_Context;
   E : Event_Type) is
begin
   Handle_Event(C.Current_State, E);
end Handle_System_Event;

-- Contract ensures valid state transitions
procedure Handle_System_Event (
   C : in out System_Context;
   E : Event_Type) with
   Contract_Cases =>
      (E = Start and C.Current_State in Idle_State =>
         C.Current_State in Running_State,
       E = Stop and C.Current_State in Running_State =>
         C.Current_State in Idle_State);</code></pre>
                </div>
                <p>
                    This pattern ensures only valid state transitions can occur.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>2. Strategy Pattern for Safe Algorithm Selection</h3>
                <p>
                    Select algorithms polymorphically:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">-- Algorithm interface
type Control_Strategy is abstract tagged null record;
function Calculate_Output (
   S : Control_Strategy;
   Input : Control_Input) return Control_Output is abstract;

-- Concrete strategies
type PID_Strategy is new Control_Strategy with record
   Kp, Ki, Kd : Float;
end record;
function Calculate_Output (
   S : PID_Strategy;
   Input : Control_Input) return Control_Output is
begin
   -- PID calculation
   null;
end Calculate_Output;

type Fuzzy_Strategy is new Control_Strategy with record
   Rules : Fuzzy_Rule_Set;
end record;
function Calculate_Output (
   S : Fuzzy_Strategy;
   Input : Control_Input) return Control_Output is
begin
   -- Fuzzy logic calculation
   null;
end Calculate_Output;

-- Context using the pattern
type Controller is tagged record
   Strategy : Control_Strategy'Class;
end record;

function Calculate (
   C : Controller;
   Input : Control_Input) return Control_Output is
begin
   return Calculate_Output(C.Strategy, Input);
end Calculate;

-- Contract ensures safety properties
function Calculate (
   C : Controller;
   Input : Control_Input) return Control_Output with
   Pre  => Valid_Input(Input),
   Post => Valid_Output(Calculate'Result) and
           Calculate'Result in SAFE_RANGE;</code></pre>
                </div>
                <p>
                    This pattern enables safe runtime algorithm selection.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>3. Visitor Pattern for Safe Data Processing</h3>
                <p>
                    Process heterogeneous data safely:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">-- Element interface
type Sensor_Element is abstract tagged null record;
procedure Accept (
   E : Sensor_Element;
   V : in out Sensor_Visitor) is abstract;

-- Concrete elements
type Temperature_Sensor is new Sensor_Element with record
   Value : Float;
end record;
procedure Accept (
   E : Temperature_Sensor;
   V : in out Sensor_Visitor) is
begin
   V.Visit_Temperature(E);
end Accept;

type Pressure_Sensor is new Sensor_Element with record
   Value : Float;
end record;
procedure Accept (
   E : Pressure_Sensor;
   V : in out Sensor_Visitor) is
begin
   V.Visit_Pressure(E);
end Accept;

-- Visitor interface
type Sensor_Visitor is abstract tagged null record;
procedure Visit_Temperature (
   V : in out Sensor_Visitor;
   S : Temperature_Sensor) is abstract;
procedure Visit_Pressure (
   V : in out Sensor_Visitor;
   S : Pressure_Sensor) is abstract;

-- Concrete visitor
type Safety_Check_Visitor is new Sensor_Visitor with null record;
procedure Visit_Temperature (
   V : in out Safety_Check_Visitor;
   S : Temperature_Sensor) is
begin
   if S.Value > MAX_TEMP then
      Trigger_Alarm;
   end if;
end Visit_Temperature;

procedure Visit_Pressure (
   V : in out Safety_Check_Visitor;
   S : Pressure_Sensor) is
begin
   if S.Value > MAX_PRESSURE then
      Trigger_Alarm;
   end if;
end Visit_Pressure;

-- Usage with safety guarantees
procedure Check_Safety (
   Elements : Sensor_Element_Array) is
   Visitor : Safety_Check_Visitor;
begin
   for E of Elements loop
      Accept(E, Visitor);
   end loop;
end Check_Safety;

-- Contract ensures all elements are checked
procedure Check_Safety (
   Elements : Sensor_Element_Array) with
   Post => 
      (for all E of Elements => 
         Is_Checked(E) = True);</code></pre>
                </div>
                <p>
                    This pattern ensures exhaustive processing of heterogeneous data.
                </p>
            </div>
        </div>
        
        <div class="note-box">
            <h3>OOP Pattern Selection Guide</h3>
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>When to Use</th>
                        <th>Safety Benefits</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>State Pattern</td>
                        <td>Complex state machines with many states</td>
                        <td>Prevents invalid state transitions</td>
                    </tr>
                    <tr>
                        <td>Strategy Pattern</td>
                        <td>Multiple algorithms for same task</td>
                        <td>Ensures algorithm safety properties</td>
                    </tr>
                    <tr>
                        <td>Visitor Pattern</td>
                        <td>Processing heterogeneous data collections</td>
                        <td>Guarantees exhaustive processing</td>
                    </tr>
                    <tr>
                        <td>Template Method</td>
                        <td>Fixed algorithm with variable steps</td>
                        <td>Maintains algorithm invariants</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Exercises: Building Verified Polymorphic Systems</h2>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Exercise 1: Avionics Control System</h3>
                <p>
                    Design a polymorphic flight control system:
                </p>
                <ul>
                    <li>Create an abstract base type for control surfaces</li>
                    <li>Implement concrete types for ailerons, elevators, rudders</li>
                    <li>Add contracts to ensure safe state transitions</li>
                    <li>Use the state pattern for control surface modes</li>
                    <li>Verify that impossible states are contractually prohibited</li>
                </ul>
                <p>
                    <strong>Challenge:</strong> Prove that the control system cannot command physically impossible movements.
                </p>
            </div>
            
            <div class="feature-card">
                <h3>Exercise 2: Medical Device Sensor Framework</h3>
                <p>
                    Build a polymorphic sensor framework for a medical device:
                </p>
                <ul>
                    <li>Design an interface for vital sign sensors</li>
                    <li>Implement concrete sensors for heart rate, blood pressure, etc.</li>
                    <li>Add contracts to ensure data validity</li>
                    <li>Use the strategy pattern for different processing algorithms</li>
                    <li>Create a verification plan for polymorphic behavior</li>
                </ul>
                <p>
                    <strong>Challenge:</strong> Prove that sensor data cannot be misinterpreted due to polymorphism.</li>
                </p>
            </div>
        </div>
        
        <div class="warning-box">
            <h3>Verification Strategy for Polymorphic Systems</h3>
            <ol>
                <li><strong>Static verification:</strong> Use gnatprove to verify contract refinement</li>
                <li><strong>Type safety:</strong> Verify all downcasts with tag checks</li>
                <li><strong>Dispatching verification:</strong> Prove correct dispatching behavior</li>
                <li><strong>State preservation:</strong> Verify invariants across dispatching</li>
                <li><strong>Path coverage:</strong> Ensure all polymorphic paths are tested</li>
                <li><strong>Formal proof:</strong> For critical components, use SPARK for mathematical verification</li>
            </ol>
            <p>
                For highest safety levels, all six verification steps are required to demonstrate safe polymorphic behavior.
            </p>
        </div>
    </div>
    
    <div class="section-divider"></div>
    
    <div class="tutorial-section">
        <h2>Next Steps: Generics and Template Programming</h2>
        <p>
            Now that you've mastered Ada's object-oriented programming features, you're ready to explore how to create reusable, type-safe components through generics. In the next tutorial, we'll dive into Ada's powerful generic programming system, showing how to:
        </p>
        
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Upcoming: Generics and Template Programming</h3>
                <ul>
                    <li>Create reusable components with formal parameters</li>
                    <li>Specify constraints on generic parameters</li>
                    <li>Verify generic code correctness</li>
                    <li>Combine generics with Design by Contract</li>
                    <li>Apply generics to safety-critical patterns</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3>Practice Challenge</h3>
                <p>
                    Enhance your avionics control system with generics:
                </p>
                <ul>
                    <li>Create generic sensor interface packages</li>
                    <li>Add constraints to ensure type safety</li>
                    <li>Implement contracts for generic operations</li>
                    <li>Verify that instantiations maintain safety properties</li>
                    <li>Create a verification plan for generic components</li>
                </ul>
            </div>
        </div>
        
        <div class="callout-secondary">
            <h4>The Path to Verified Reusability</h4>
            <p>
                Object-oriented programming provides the foundation for building flexible systems, but generics enable building flexible systems <em>efficiently</em>. When combined with strong typing, Design by Contract, and formal verification, Ada's generic system creates a powerful framework for developing and certifying reusable components.
            </p>
            <p>
                This integrated approach is why Ada remains the language of choice for organizations that need both flexibility and safety-critical reliability. As you progress through this tutorial series, you'll see how these techniques combine to create software that's not just functionally correct, but <em>economically sustainable</em> throughout its lifecycle.
            </p>
        </div>
    </div>
</div>
