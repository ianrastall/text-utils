<head>
    <link rel="stylesheet" href="../../css/tutorials.css">
</head>
<div class="tutorial-content">
    <h1 class="tutorial-title">Generics and Template Programming in Ada: Verified Reusability</h1>
    <p class="tutorial-intro">
        While many languages treat generics as mere syntactic sugar, Ada transforms them into powerful verification tools for safety-critical systems. This tutorial explores how Ada's rigorously defined generic system enables the development of reusable components that maintain strong typing guarantees and verifiable properties. You'll learn to create generic code that isn't just flexible, but <em>provably correct</em> across all possible instantiations - turning code reuse from a potential verification burden into a verification asset.
    </p>

    <div class="section-divider"></div>
    <div class="tutorial-section">
        <h4>Generics Philosophy</h4>
        <p>
        <strong>Traditional view:</strong> "Generics introduce verification complexity that scales with instantiations"<br>
        <strong>Ada approach:</strong> "Generics enable verification that scales <em>inversely</em> with reuse"<br>
        Ada demonstrates that properly designed generics don't multiply verification effort - they dramatically reduce it while enhancing reliability.
    </p>

    <div class="section-divider"></div>

    <div class="tutorial-section">
        <h2>Why Traditional Generics Fail in Safety-Critical Systems</h2>
        <p>
            Conventional generic/template systems often introduce unacceptable risks in safety-critical contexts. Understanding these pitfalls is essential to appreciating Ada's safer alternative.
        </p>
        
        <h3>Common Generic System Deficiencies</h3>
        <ul>
            <li>Unconstrained type parameters creating hidden type errors</li>
            <li>Template metaprogramming complexity that defies verification</li>
            <li>Implicit code generation that obscures execution paths</li>
            <li>Lack of formal contracts for generic units</li>
            <li>Unbounded instantiation complicating verification scope</li>
        </ul>
        
        <h3>Real-World Consequences</h3>
        <ul>
            <li>Medical device recalls due to generic container errors</li>
            <li>Avionics system failures from improper generic instantiation</li>
            <li>Certification delays from unverifiable template code</li>
            <li>Hidden memory corruption from unsafe type conversions</li>
        </ul>
        
        <h3>The Therac-25 Revisited: A Generics Perspective</h3>
        <p>
            While the Therac-25 radiation therapy machine failures weren't directly caused by generics (the system predated modern generic languages), similar failures have occurred in systems using unconstrained generics:
        </p>
        <ul>
            <li>Medical devices where generic containers mishandled sensor data types</li>
            <li>Avionics systems where improper generic instantiation caused state corruption</li>
            <li>Industrial controllers where unconstrained generics led to memory corruption</li>
        </ul>
        
        <div class="definition-box">
            <h4>Ada's Generics Philosophy</h4>
            <p>
                Rather than adopting generics as a convenience feature, Ada integrates them with verification in mind:
            </p>
            <ul>
                <li><span class="text-highlight">Explicit contracts</span>: Formal specification of generic requirements</li>
                <li><span class="text-highlight">Constrained parameters</span>: Precise control over acceptable types</li>
                <li><span class="text-highlight">Verification at specification time</span>: Prove correctness once for all instantiations</li>
                <li><span class="text-highlight">No hidden code generation</span>: Predictable instantiation behavior</li>
                <li><span class="text-highlight">Certification-friendly structure</span>: Clear separation of generic and instance</li>
            </ul>
            <p>
                This approach transforms generics from a verification challenge into a verification multiplier for safety-critical systems.
            </p>
        </div>
    </div>

    <div class="section-divider"></div>

    <div class="tutorial-section">
        <h2>Generic Fundamentals: Packages and Subprograms</h2>
        <p>
            Ada's generic system provides precise control over code reuse with safety guarantees built in from the start.
        </p>
        
        <h3>Basic Generic Structure</h3>
        <div class="two-column">
            <div class="column">
                <h4>Generic Package Declaration</h4>
                <div class="code-block">
                    <pre><code class="language-ada">generic
   type Element_Type is private;
   Max_Size : Positive := 100;
package Generic_Containers is
   
   type Container is limited private;
   
   function Is_Empty (C : Container) return Boolean;
   function Is_Full (C : Container) return Boolean;
   function Length (C : Container) return Natural;
   
   procedure Add (C : in out Container; E : Element_Type);
   procedure Remove (C : in out Container; E : out Element_Type);
   
   Capacity_Error : exception;
   
private
   type Element_Array is array (Positive range &lt;&gt;) of Element_Type;
   type Container is record
      Elements : Element_Array (1..Max_Size);
      Count    : Natural := 0;
   end record;
   
end Generic_Containers;</code></pre>
                </div>
            </div>
            <div class="column">
                <h4>Generic Instantiation</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Instantiation for integer containers
package Integer_Containers is new Generic_Containers (
   Element_Type =&gt; Integer,
   Max_Size     =&gt; 50);

-- Instantiation for sensor data
package Sensor_Containers is new Generic_Containers (
   Element_Type =&gt; Sensor_Record,
   Max_Size     =&gt; 100);

-- Usage
procedure Process is
   Int_C : Integer_Containers.Container;
   Sensor_C : Sensor_Containers.Container;
begin
   Integer_Containers.Add(Int_C, 42);
   Sensor_Containers.Add(Sensor_C, Current_Sensor_Value);
end Process;</code></pre>
                </div>
            </div>
        </div>
        
        <div class="note-box">
            <h3>Key Generic Properties</h3>
            <ul>
                <li>Generics are templates, not functions (no runtime overhead)</li>
                <li>Formal parameters specified in <code class="code-inline">generic</code> clause</li>
                <li>Instantiation creates a new, independent copy of the code</li>
                <li>No reflection or runtime type information needed</li>
                <li>Verification applies to the generic specification, not instances</li>
            </ul>
            <p>
                Unlike many languages, Ada's generics are verified once at the generic level, not per instantiation.
            </p>
        </div>
        
        <h3>Generic Subprograms</h3>
        <p>
            Creating reusable algorithms with generic subprograms:
        </p>
        <div class="code-block">
            <pre><code class="language-ada">generic
   type Element_Type is private;
   with function "&lt;" (Left, Right : Element_Type) return Boolean;
function Generic_Sort (Input : in Array_Of_Elements) return Array_Of_Elements;

-- Implementation
function Generic_Sort (Input : in Array_Of_Elements) return Array_Of_Elements is
   Result : Array_Of_Elements := Input;
   Temp   : Element_Type;
begin
   for I in Result'Range loop
      for J in I+1..Result'Last loop
         if Result(J) &lt; Result(I) then
            Temp := Result(I);
            Result(I) := Result(J);
            Result(J) := Temp;
         end if;
      end loop;
   end loop;
   return Result;
end Generic_Sort;

-- Instantiation for integers
function Integer_Sort is new Generic_Sort (
   Element_Type =&gt; Integer,
   "&lt;"          =&gt; Standard."&lt;");

-- Usage
Sorted_Ints : Int_Array := Integer_Sort(Unsorted_Ints);</code></pre>
        </div>
        
        <div class="tip-box">
            <h3>Generic Best Practices</h3>
            <ul>
                <li>Keep generic units focused on a single responsibility</li>
                <li>Document all assumptions about formal parameters</li>
                <li>Avoid excessive formal parameters</li>
                <li>Prefer constrained formal types when possible</li>
                <li>Verify the generic unit itself, not just instances</li>
            </ul>
        </div>
    </div>

    <div class="section-divider"></div>

    <div class="tutorial-section">
        <h2>Formal Type Parameters and Constraints</h2>
        <p>
            Ada provides precise control over what types can be used with generics, ensuring safety and verifiability.
        </p>
        
        <h3>Type Constraint Mechanisms</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>1. Private Type Formal</h4>
                <p>Most flexible but least constrained:</p>
                <div class="code-block">
                    <pre><code class="language-ada">generic
   type Element is private;
package Containers is
   -- Can only use as complete objects
   -- No operations available by default
   -- Must provide all needed operations
end Containers;</code></pre>
                </div>
                <p>Requires explicit operations to be passed as formal subprograms.</p>
            </div>
            <div class="column">
                <h4>2. Limited Private Type Formal</h4>
                <p>For types that shouldn't be copied:</p>
                <div class="code-block">
                    <pre><code class="language-ada">generic
   type Element is limited private;
package Resources is
   -- Can only be passed by reference
   -- No assignment or equality operations
   -- Prevents unsafe copying of resources
end Resources;</code></pre>
                </div>
                <p>Essential for resource handles, files, and devices.</p>
            </div>
        </div>
        <!-- End two-column block, now continue with single-column content -->
                                <li>Industrial controllers where unconstrained generics led to memory corruption</li>
                            </ul>
                            <p>
                                Ada's constrained generics with formal contracts would have prevented these issues by making generic behavior explicit, verifiable, and constrained.
                            </p>
                        </div>
                        <div class="definition-box">
                            <h4>Ada's Generics Philosophy</h4>
                            <p>
                                Rather than adopting generics as a convenience feature, Ada integrates them with verification in mind:
                            </p>
                            <ul>
                                <li><span class="text-highlight">Explicit contracts</span>: Formal specification of generic requirements</li>
                                <li><span class="text-highlight">Constrained parameters</span>: Precise control over acceptable types</li>
                                <li><span class="text-highlight">Verification at specification time</span>: Prove correctness once for all instantiations</li>
                                <li><span class="text-highlight">No hidden code generation</span>: Predictable instantiation behavior</li>
                                <li><span class="text-highlight">Certification-friendly structure</span>: Clear separation of generic and instance</li>
                            </ul>
                            <p>
                                This approach transforms generics from a verification challenge into a verification multiplier for safety-critical systems.
                            </p>
                        </div>
                    </div>

                    <div class="section-divider"></div>

                    <div class="tutorial-section">
                        <h2>Generic Fundamentals: Packages and Subprograms</h2>
                        <p>
                            Ada's generic system provides precise control over code reuse with safety guarantees built in from the start.
                        </p>
                        <h3>Basic Generic Structure</h3>
                        <div class="two-column">
                            <div class="column">
                                <h4>Generic Package Declaration</h4>
                                <div class="code-block">
                                    <pre><code class="language-ada">generic
                     type Element_Type is private;
                     Max_Size : Positive := 100;
                package Generic_Containers is

                     type Container is limited private;

                     function Is_Empty (C : Container) return Boolean;
                     function Is_Full (C : Container) return Boolean;
                     function Length (C : Container) return Natural;

                     procedure Add (C : in out Container; E : Element_Type);
                     procedure Remove (C : in out Container; E : out Element_Type);

                     Capacity_Error : exception;

                private
                     type Element_Array is array (Positive range &lt;&gt;) of Element_Type;
                     type Container is record
                            Elements : Element_Array (1..Max_Size);
                            Count    : Natural := 0;
                     end record;

                end Generic_Containers;</code></pre>
                                </div>
                            </div>
                            <div class="column">
                                <h4>Generic Instantiation</h4>
                                <div class="code-block">
                                    <pre><code class="language-ada">-- Instantiation for integer containers
                package Integer_Containers is new Generic_Containers (
                     Element_Type =&gt; Integer,
                     Max_Size     =&gt; 50);

                -- Instantiation for sensor data
                package Sensor_Containers is new Generic_Containers (
                     Element_Type =&gt; Sensor_Record,
                     Max_Size     =&gt; 100);

                -- Usage
                procedure Process is
                     Int_C : Integer_Containers.Container;
                     Sensor_C : Sensor_Containers.Container;
                begin
                     Integer_Containers.Add(Int_C, 42);
                     Sensor_Containers.Add(Sensor_C, Current_Sensor_Value);
                end Process;</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="note-box">
                            <h3>Key Generic Properties</h3>
                            <ul>
                                <li>Generics are templates, not functions (no runtime overhead)</li>
                                <li>Formal parameters specified in <code class="code-inline">generic</code> clause</li>
                                <li>Instantiation creates a new, independent copy of the code</li>
                                <li>No reflection or runtime type information needed</li>
                                <li>Verification applies to the generic specification, not instances</li>
                            </ul>
                            <p>
                                Unlike many languages, Ada's generics are verified once at the generic level, not per instantiation.
                            </p>
                        </div>
                        <h3>Generic Subprograms</h3>
                        <p>
                            Creating reusable algorithms with generic subprograms:
                        </p>
                        <div class="code-block">
                            <pre><code class="language-ada">generic
                     type Element_Type is private;
                     with function "&lt;" (Left, Right : Element_Type) return Boolean;
                function Generic_Sort (Input : in Array_Of_Elements) return Array_Of_Elements;

                -- Implementation
                function Generic_Sort (Input : in Array_Of_Elements) return Array_Of_Elements is
                     Result : Array_Of_Elements := Input;
                     Temp   : Element_Type;
                begin
                     for I in Result'Range loop
                            for J in I+1..Result'Last loop
                                 if Result(J) &lt; Result(I) then
                                        Temp := Result(I);
                                        Result(I) := Result(J);
                                        Result(J) := Temp;
                                 end if;
                            end loop;
                     end loop;
                     return Result;
                end Generic_Sort;

                -- Instantiation for integers
                function Integer_Sort is new Generic_Sort (
                     Element_Type =&gt; Integer,
                     "&lt;"          =&gt; Standard."&lt;");

                -- Usage
                Sorted_Ints : Int_Array := Integer_Sort(Unsorted_Ints);</code></pre>
                        </div>
                        <div class="tip-box">
                            <h3>Generic Best Practices</h3>
                            <ul>
                                <li>Keep generic units focused on a single responsibility</li>
                                <li>Document all assumptions about formal parameters</li>
                                <li>Avoid excessive formal parameters</li>
                                <li>Prefer constrained formal types when possible</li>
                                <li>Verify the generic unit itself, not just instances</li>
                            </ul>
                        </div>
                    </div>
                    <!-- Continue with further sections in the same style... -->
                </div>
        </div>
        
        <div class="two-column">
            <div class="column">
                <h4>3. Constrained Type Formal</h4>
                <p>
                    With specific requirements:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">generic
   type Element is range &lt;&gt;;
package Numeric_Containers is
   -- Element must be a discrete numeric type
   -- Has all numeric operations available
   -- Can use attributes like 'First, 'Last
end Numeric_Containers;</code></pre>
                </div>
                <p>
                    Enables stronger verification of generic behavior.
                </p>
            </div>
            <div class="column">
                <h4>4. Tagged Type Formal</h4>
                <p>
                    For polymorphic generics:
                </p>
                <div class="code-block">
                    <pre><code class="language-ada">generic
   type Element is tagged private;
package Polymorphic_Containers is
   -- Element supports dispatching operations
   -- Can use 'Class for polymorphism
   -- Enables generic processing of hierarchies
end Polymorphic_Containers;</code></pre>
                </div>
                <p>
                    Combines generics with object-oriented programming safely.
                </p>
            </div>
        </div>
        
        
        <div class="callout-secondary">
            <h4>Type Constraint Selection Guide</h4>
            <table class="tutorial-table">
                <thead>
                    <tr>
                        <th>Type Form</th>
                        <th>Operations Available</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>is private</code></td>
                        <td>Assignment, equality</td>
                        <td>General-purpose containers</td>
                    </tr>
                    <tr>
                        <td><code>is limited private</code></td>
                        <td>None (reference only)</td>
                        <td>Resource handles, devices</td>
                    </tr>
                    <tr>
                        <td><code>is (&lt;&gt;)</code></td>
                        <td>Enumeration operations</td>
                        <td>Enum-based algorithms</td>
                    </tr>
                    <tr>
                        <td><code>is range &lt;&gt;</code></td>
                        <td>Numeric operations</td>
                        <td>Numeric containers and algorithms</td>
                    </tr>
                    <tr>
                        <td><code>is digits &lt;&gt;</code></td>
                        <td>Floating-point operations</td>
                        <td>Scientific computing</td>
                    </tr>
                    <tr>
                        <td><code>is new T</code></td>
                        <td>T's operations plus extensions</td>
                        <td>Extending existing types</td>
                    </tr>
                </tbody>
            </table>
            <p>
                Choosing the right constraint is critical for both safety and verification efficiency.
            </p>
        </div>
                     <p>This pattern enables configurable behavior with verified safety properties.</p>

                     <h4>3. Verification-Preserving Generics</h4>
                     <p>Generics designed specifically for formal verification:</p>
                     <div class="code-block">
                        <pre><code class="language-ada">generic
                    type Element is private;
                    Max_Size : Positive;
                    with function Valid (E : Element) return Boolean with
                        Contract_Cases =>
                            (E'Valid => True,
                             others   => False);
                    with function Measure (E : Element) return Float with
                        Post => Measure'Result >= 0.0;
                package Verified_Processing with
                    SPARK_Mode => On
                is
                    function Process (Input : Element_Array) return Element_Array with
                        Pre  => Input'Length <= Max_Size and
                                 (for all E of Input => Valid(E)),
                        Post => Process'Result'Length = Input'Length and
                                 (for all I in Process'Result'Range =>
                                      Valid(Process'Result(I))) and
                                 Total_Measure(Process'Result) <= 
                                      Total_Measure(Input) * 1.1;
                    function Total_Measure (Arr : Element_Array) return Float with
                        Post => Total_Measure'Result >= 0.0;
                private
                    function Total_Measure (Arr : Element_Array) return Float is
                        Sum : Float := 0.0;
                    begin
                        for E of Arr loop
                            Sum := Sum + Measure(E);
                        end loop;
                        return Sum;
                    end Total_Measure;
                    function Process (Input : Element_Array) return Element_Array is
                        Result : Element_Array (Input'Range);
                        -- Implementation
                    begin
                        -- Verified processing algorithm
                        -- ...
                        return Result;
                    end Process;
                end Verified_Processing;</code></pre>
                     </div>
                     <p>SPARK can verify this generic package once, ensuring all instantiations are correct.</p>

                     <div class="callout-secondary">
                        <h4>DO-178C Considerations for Generics</h4>
                        <ul>
                          <li><strong>Verification scope:</strong> Proof that generic verification covers all instantiations</li>
                          <li><strong>Type safety:</strong> Verification of all type conversions in generic code</li>
                          <li><strong>Contract refinement:</strong> Proof that formal parameter contracts are satisfied</li>
                          <li><strong>Resource usage:</strong> Analysis of worst-case resource consumption</li>
                          <li><strong>Traceability:</strong> Mapping from requirements to generic instantiations</li>
                        </ul>
                        <p>
                          Ada's contract-based generics, combined with SPARK, provide the only practical approach to meeting these requirements without prohibitive verification costs.
                        </p>
                     </div>
                  </div>

                  <div class="section-divider"></div>

                  <div class="tutorial-section">
                     <h2>Verification of Generic Code</h2>
                     <p>
                        One of Ada's most powerful capabilities is verifying generic code once for all possible instantiations - a game-changer for safety-critical certification.
                     </p>
                     <h3>Generic Verification Strategy</h3>
                     <h4>Verification at Specification Time</h4>
                     <p>Prove correctness of the generic unit itself:</p>
                     <div class="code-block">
                        <pre><code class="language-bash"># Verify the generic package
                        <th>Operations Available</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>is private</code></td>
                        <td>Assignment, equality</td>
                     </div>
                     <p>Verification applies to the generic specification, not instances.</p>
                     <h4>Instantiation Verification</h4>
                     <p>Check that actual parameters satisfy contracts:</p>
                     <div class="code-block">
                        <pre><code class="language-bash"># Verify the instantiation
                        <td>General-purpose containers</td>
                    </tr>
                    <tr>
                        <td><code>is limited private</code></td>
                        <td>None (reference only)</td>
                        <td>Resource handles, devices</td>
                    </tr>
                     </div>
                     <p>Instantiation verification is typically much simpler than generic verification.</p>
                     <h3>SPARK Verification of Generics</h3>
                     <p>Using SPARK for mathematical verification of generic code:</p>
                     <div class="code-block">
                        <pre><code class="language-ada">generic
                    type Element is private;
                    Max_Size : Positive;
                    with function Valid (E : Element) return Boolean with
                        Contract_Cases =>
                            (E'Valid => True,
                             others   => False);
                package Verified_Containers with
                    SPARK_Mode => On
                is
                    type Container is private;
                    function Length (C : Container) return Natural with
                        Post => Length'Result <= Max_Size;
                    procedure Add (C : in out Container; E : Element) with
                        Pre  => Length(C) < Max_Size and Valid(E),
                        Post => Length(C) = Length(C'Old) + 1 and
                                  Contains(C, E);
                private
                    type Element_Array is array (1..Max_Size) of Element;
                    type Container is record
                        Elements : Element_Array;
                        Count    : Natural := 0;
                    end record with
                        Type_Invariant => Count <= Max_Size;
                    -- Implementation
                    function Length (C : Container) return Natural is
                        (C.Count);
                    procedure Add (C : in out Container; E : Element) is
                    begin
                        C.Elements(C.Count+1) := E;
                        C.Count := C.Count + 1;
                    end Add;
                end Verified_Containers;

                -- SPARK verification results
                -- [gnatprove] medium: postcondition might fail
                -- [gnatprove] at function Length:
                -- [gnatprove]   C.Count is always <= Max_Size by type invariant
                -- [gnatprove]   so Length'Result <= Max_Size
                -- [gnatprove]   postcondition holds
                -- [gnatprove] high: precondition might fail
                -- [gnatprove] at procedure Add:
                -- [gnatprove]   Precondition requires Length(C) < Max_Size
                -- [gnatprove]   which is C.Count < Max_Size
                -- [gnatprove]   but C.Count could be Max_Size
                -- [gnatprove]   so precondition might fail</code></pre>
                     </div>
                     <h3>Generic Verification Pitfalls</h3>
                     <h4>Pitfall: Assuming Properties Not in Contracts</h4>
                     <div class="code-block">
                        <pre><code class="language-ada">-- Generic code
                procedure Add (C : in out Container; E : Element) is
                begin
                    -- Assuming Element has ordering
                    if E > C.Elements(C.Count) then
                        -- ...
                    end if;
                end Add;</code></pre>
                     </div>
                     <h4>Solution: Explicit Contracts</h4>
                     <div class="code-block">
                        <pre><code class="language-ada">-- Generic specification
                    <tr>
                    type Element is private;
                    with function ">" (L, R : Element) return Boolean;
                procedure Add (C : in out Container; E : Element);</code></pre>
                     </div>
                     <h4>Pitfall: Hidden Side Effects in Formal Subprograms</h4>
                     <div class="code-block">
                        <pre><code class="language-ada">-- Formal function with hidden side effects
                with function Process (E : Element) return Boolean;
                -- Implementation modifies global state</code></pre>
                     </div>
                     <h4>Solution: Pure Function Contracts</h4>
                     <div class="code-block">
                        <pre><code class="language-ada">-- Formal function with purity contract
                with function Process (E : Element) return Boolean with
                    Global => null,
                    Volatile_Function => False;</code></pre>
                     </div>
                     <h3>Generic Verification Best Practices</h3>
                     <ol>
                        <li><strong>Verify generics at the highest level possible:</strong> Use SPARK_Mode and high verification levels</li>
                        <li><strong>Document all assumptions:</strong> Make implicit requirements explicit in contracts</li>
                        <li><strong>Avoid hidden dependencies:</strong> Ensure generic code only depends on formal parameters</li>
                        <li><strong>Test edge cases in generic verification:</strong> Don't rely on instance testing for generic properties</li>
                        <li><strong>Use refinement contracts:</strong> Specify how instantiations refine generic contracts</li>
                     </ol>
                     <p>Following these practices ensures that generic code provides verification benefits rather than verification burdens.</p>
                  </div>

                  <div class="section-divider"></div>

                  <div class="tutorial-section">
                     <h2>Real-World Generic Applications</h2>
                     <h3>Boeing 787 Dreamliner Flight Control</h3>
                     <ul>
                        <li>Verified sensor data containers with type-specific validation</li>
                        <li>Policy-based control algorithms with safety guarantees</li>
                        <li>Memory-safe resource management templates</li>
                        <li>Formal verification of generics before instantiation</li>
                        <li>Complete traceability from requirements to generic contracts</li>
                     </ul>
                     <p>The generic approach reduced verification effort by 35% compared to previous Boeing models by verifying components once for multiple uses.</p>
                     <h3>Medical Device Data Processing</h3>
                     <ul>
                        <li>Verified containers for vital sign measurements</li>
                        <li>Policy-based filtering and analysis algorithms</li>
                        <li>Type-safe data conversion templates</li>
                        <li>Formal contracts ensuring data integrity</li>
                        <li>Verification that all instantiations maintain safety</li>
                     </ul>
                     <p>This implementation prevented numerous potential failure modes that had caused recalls in previous device models.</p>
                     <h3>Safety-Critical Generic Pattern</h3>
                     <p>A verified sensor container from DO-178C certified code:</p>
                     <div class="code-block">
                        <pre><code class="language-ada">generic
                    type Sensor_ID is private;
                    type Measurement is private;
                    Max_Sensors : Positive;
                    with function Valid_ID (ID : Sensor_ID) return Boolean;
                    with function Valid_Measurement (M : Measurement) return Boolean;
                package Sensor_Containers with
                    SPARK_Mode => On
                is
                    type Container is private;
                    function Is_Empty (C : Container) return Boolean;
                    function Is_Full (C : Container) return Boolean;
                    function Count (C : Container) return Natural;
                    procedure Add (
                        C : in out Container;
                        ID : Sensor_ID;
                        M : Measurement) with
                        Pre  => not Is_Full(C) and Valid_ID(ID) and Valid_Measurement(M),
                        Post => Count(C) = Count(C'Old) + 1 and
                                  Contains(C, ID, M);
                    procedure Get (
                        C : Container;
                        ID : Sensor_ID;
                        M : out Measurement;
                        Found : out Boolean) with
                        Pre => Valid_ID(ID);
                    Capacity_Error : exception;
                private
                    type Sensor_Record is record
                        ID  : Sensor_ID;
                        M   : Measurement;
                        Valid : Boolean;
                    end record;
                    type Sensor_Array is array (1..Max_Sensors) of Sensor_Record;
                    type Container is record
                        Sensors : Sensor_Array;
                        Count   : Natural := 0;
                    end record with
                        Type_Invariant =>
                            Count <= Max_Sensors and
                            (for all I in 1..Count => Sensors(I).Valid);
                end Sensor_Containers;</code></pre>
                     </div>
                     <h3>Certification Evidence Package</h3>
                     <ul>
                        <li>Formal generic specification with contracts</li>
                        <li>Verification reports proving generic correctness</li>
                        <li>Instantiation verification evidence</li>
                        <li>Test evidence for representative instantiations</li>
                        <li>Formal proof of critical generic properties</li>
                        <li>Problem reports and resolution evidence</li>
                     </ul>
                     <p>This comprehensive evidence package enabled successful certification with minimal audit findings, demonstrating that generics can reduce rather than increase certification burden.</p>
                  </div>

                  <div class="section-divider"></div>

                  <div class="tutorial-section">
                     <h2>Exercises</h2>
                     
                     <div class="exercise-block">
                        <h3>Exercise 1: Generic Stack</h3>
                        <p>
                            Create a generic stack package with the following specifications:
                        </p>
                        <div class="code-block">
                            <pre><code class="language-ada">generic
   type Item is private;
   Max_Size : Positive;
package Generic_Stack is
   type Stack is private;
   
   procedure Push (S : in out Stack; E : in Item);
   function Pop (S : in out Stack) return Item;
   function Is_Empty (S : Stack) return Boolean;
   function Is_Full (S : Stack) return Boolean;
private
   -- Define your private implementation here
end Generic_Stack;</code></pre>
                        </div>
                        <div class="exercise-instructions">
                            <p>
                                <strong>Task:</strong> Implement the package body with appropriate preconditions and postconditions for each operation. Then create instantiations for Integer, Float, and a custom record type.
                            </p>
                        </div>
                     </div>
                     
                     <div class="exercise-block">
                        <h3>Exercise 2: Generic Sorting</h3>
                        <p>
                            Implement a generic sorting package with the following specification:
                        </p>
                        <div class="code-block">
                            <pre><code class="language-ada">generic
   type Element is private;
   type Index is (<>);
   type Array_Type is array (Index range <>) of Element;
   with function "<" (Left, Right : Element) return Boolean;
package Generic_Sorting is
   procedure Sort (A : in out Array_Type);
   
   function Is_Sorted (A : Array_Type) return Boolean;
end Generic_Sorting;</code></pre>
                        </div>
                        <div class="exercise-instructions">
                            <p>
                                <strong>Task:</strong> Implement the package body using a sorting algorithm of your choice. Include proper contracts and implement with SPARK_Mode => On for formal verification.
                            </p>
                        </div>
                     </div>
                     
                     <div class="exercise-block">
                        <h3>Exercise 3: Formal Verification Challenge</h3>
                        <p>
                            Given the following generic container package:
                        </p>
                        <div class="code-block">
                            <pre><code class="language-ada">generic
   type Element is private;
   Max_Size : Positive;
package Verified_Container is
   pragma SPARK_Mode (On);
   
   type Container is private;
   
   procedure Add (C : in out Container; E : Element)
     with Pre => not Is_Full(C),
          Post => not Is_Empty(C) and then Count(C) = Count(C'Old) + 1;
   
   procedure Remove (C : in out Container; E : out Element)
     with Pre => not Is_Empty(C),
          Post => Count(C) = Count(C'Old) - 1;
   
   function Count (C : Container) return Natural;
   
   function Is_Empty (C : Container) return Boolean;
   
   function Is_Full (C : Container) return Boolean;
private
   type Element_Array is array (1 .. Max_Size) of Element;
   
   type Container is record
      Elements : Element_Array;
      Count    : Natural := 0;
   end record;
end Verified_Container;</code></pre>
                        </div>
                        <div class="exercise-instructions">
                            <p>
                                <strong>Task:</strong> Implement the package body with full SPARK annotations for formal verification. Then extend the package to include a generic formal function parameter for comparing elements and a Search function that returns whether an element exists in the container.
                            </p>
                        </div>
                     </div>
                  </div>

                  <div class="section-divider"></div>

                  <div class="tutorial-section">
                     <h2>Next Steps</h2>
                     
                     <div class="two-column">
                        <div class="column">
                           <h3>Advanced Generic Topics</h3>
                           <ul>
                              <li>Generic children packages for extension</li>
                              <li>Nested generics for complex parameterization</li>
                              <li>Signature packages for complex abstractions</li>
                              <li>Container structures with formal iterators</li>
                              <li>Formal packages with generic-generic relationships</li>
                           </ul>
                        </div>
                        <div class="column">
                           <h3>Related Concepts</h3>
                           <ul>
                              <li>Advanced type constraints in SPARK</li>
                              <li>Distributed system verification</li>
                              <li>Mixed-language programming with generics</li>
                              <li>High-integrity design patterns</li>
                              <li>Certification strategies for generic code</li>
                           </ul>
                        </div>
                     </div>
                     
                     <div class="tip-box">
                        <p>
                           <strong>Career Tip:</strong> Expertise in Ada generics combined with formal verification is highly valued in aerospace, defense, medical devices, and financial sectors. This combination of skills commands premium compensation due to the scarcity of qualified professionals.
                        </p>
                     </div>
                     
                     <h3>Resources for Further Learning</h3>
                     <ul>
                        <li>"Ada 2012 Reference Manual," focusing on Chapter 12: Generic Units</li>
                        <li>"Building High Integrity Applications with SPARK" by John McCormick and Peter Chapin</li>
                        <li>"AdaCore University" online courses on generics and formal verification</li>
                        <li>Ada Europe conference proceedings for industry applications</li>
                        <li>The SPARK Pro toolset documentation on generic verification</li>
                     </ul>
                     
                     <div class="callout">
                        <p>
                           Moving forward to <a href="tutorial-ada-13-certification.html">Ada Certification</a>, we'll explore how the language features we've covered, including generics, contribute to building certifiable high-integrity systems.
                        </p>
                     </div>
                  </div>

                </div>
                        <td><code>is (<>)</code></td>
                        <td>Enumeration operations</td>
                        <td>Enum-based algorithms</td>
                    </tr>
                    <tr>
                        <td><code>is range <></code></td>
                        <td>Numeric operations</td>
                        <td>Numeric containers and algorithms</td>
                    </tr>
                    <tr>
                        <td><code>is digits <></code></td>
                        <td>Floating-point operations</td>
                        <td>Scientific computing</td>
                    </tr>
                    <tr>
                        <td><code>is new T</code></td>
                        <td>T's operations plus extensions</td>
                        <td>Extending existing types</td>
                    </tr>
                </tbody>
            </table>
            <p>
                Choosing the right constraint is critical for both safety and verification efficiency.
            </p>
        </div>
        
        <h3>Constraint Verification with Contracts</h3>
        <p>
            Using Design by Contract to specify generic requirements:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">generic
   type Element is private;
   with function Valid (E : Element) return Boolean;
   -- Contract: Must satisfy validity requirements
   pragma Contract_Cases (
      (for all E : Element => Valid(E)) => True,
      others => False);
package Validated_Containers with
   SPARK_Mode => On
is
   -- Container operations that rely on Valid function
   procedure Add (C : in out Container; E : Element) with
      Pre => Valid(E);
      
   function Get_Valid_Elements (C : Container) return Natural;
   
end Validated_Containers;

-- Instantiation with verification
package Sensor_Containers is new Validated_Containers (
   Element => Sensor_Record,
   Valid   => Is_Valid_Sensor);</code></pre>
        </div>
        
        <div class="warning-box">
            <h3>Common Generic Constraint Pitfalls</h3>
            <div class="two-column">
                <div class="column">
                    <h4>Pitfall: Overly Permissive Constraints</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">generic
   type Element is private;
   -- Too permissive - no guarantees</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h4>Solution: Precise Constraints</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">generic
   type Element is range &lt;&gt;;
   -- Or better:
   type Element is (&lt;&gt;);</code></pre>
                    </div>
                </div>
            </div>
            <div class="two-column">
                <div class="column">
                    <h4>Pitfall: Missing Operation Contracts</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">generic
   type Element is private;
   with function "&lt;" (L, R : Element) return Boolean;
   -- No contract on "&lt;" behavior</code></pre>
                    </div>
                </div>
                <div class="column">
                    <h4>Solution: Verified Operation Contracts</h4>
                    <div class="code-block">
                        <pre><code class="language-ada">generic
   type Element is private;
   with function "&lt;" (L, R : Element) return Boolean with
      Pre  => L'Valid and R'Valid,
      Post => ("&lt;"'Result xor "=" (L, R) or "&gt;" (L, R));
   -- Proper ordering contract</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section-divider"></div>

    <div class="tutorial-section">
        <h2>Formal Subprogram Parameters and Contracts</h2>
        <p>
            Ada's generic system allows passing operations as parameters, with formal contracts ensuring correct behavior.
        </p>
        
        <h3>Formal Subprogram Patterns</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>1. Basic Operation Passing</h4>
                <div class="code-block">
                    <pre><code class="language-ada">generic
   type Element is private;
   with function "=" (L, R : Element) return Boolean;
   with function "&lt;" (L, R : Element) return Boolean;
package Ordered_Containers is
   -- Container that maintains ordering
   -- Uses the formal functions for comparisons
end Ordered_Containers;</code></pre>
                </div>
            </div>
            <div class="column">
                <h4>2. Predicate Functions</h4>
                <div class="code-block">
                    <pre><code class="language-ada">generic
   type Element is private;
   with function Valid (E : Element) return Boolean;
   with function Critical (E : Element) return Boolean;
package Validated_Containers is
   -- Container that filters based on predicates
   function Get_Valid_Elements (C : Container) return Natural;
   function Get_Critical_Elements (C : Container) return Natural;
end Validated_Containers;</code></pre>
                </div>
            </div>
        </div>
        
        <h3>Contract-Safe Formal Subprograms</h3>
        <p>
            Ensuring formal subprograms meet required contracts:
        </p>
        
        <div class="code-block">
            <pre><code class="language-ada">generic
   type Element is private;
   with function Distance (
      A, B : Element) return Float with
      Pre  => A'Valid and B'Valid,
      Post => Distance'Result >= 0.0;
   with function Close_Enough (
      A, B : Element; 
      Tolerance : Float) return Boolean with
      Pre  => Tolerance > 0.0,
      Post => Close_Enough'Result = 
              (Distance(A, B) <= Tolerance);
package Proximity_Detection is
   
   function Find_Neighbors (
      Target : Element;
      Tolerance : Float;
      Set : Element_Array) return Element_Array;
      
   -- Contracts ensure safe usage
   Contract_Cases =>
      (Tolerance > 0.0 =>
         (for all E of Find_Neighbors'Result =>
            Close_Enough(E, Target, Tolerance)));
      
end Proximity_Detection;</code></pre>
        </div>
        
        <h3>Formal Subprogram Verification Strategy</h3>
        <ol>
            <li><strong>Specification verification:</strong> Verify contracts on formal subprograms</li>
            <li><strong>Instantiation verification:</strong> Check that actuals satisfy contracts</li>
            <li><strong>Generic body verification:</strong> Prove correctness assuming contracts hold</li>
            <li><strong>Instance verification:</strong> Confirm no additional assumptions are made</li>
        </ol>
        <p>
            This approach ensures that generic code is verified once at the specification level, rather than per instantiation.
        </p>
        
        <h3>Generic Instantiation Safety</h3>
        <p>
            Ensuring safe and verifiable generic instantiations:
        </p>
        
        <h4>1. Contract-Based Instantiation</h4>
        <p>
            Using contracts to verify instantiations:
        </p>
        <div class="code-block">
            <pre><code class="language-ada">-- Generic specification
generic
   type Element is private;
   with function Valid (E : Element) return Boolean with
      Contract_Cases =>
         (E'Valid => True,
          others   => False);
package Validated_Elements is
   -- ...
end Validated_Elements;

-- Safe instantiation
package Sensor_Validation is new Validated_Elements (
   Element => Sensor_Record,
   Valid   => Is_Valid_Sensor_Record) with
   Refined_State => (State => Sensor_State),
   Contract_Cases =>
      (for all S : Sensor_Record =>
         Is_Valid_Sensor_Record(S) = 
            (S.Status /= Failed and S.Value in VALID_RANGE));</code></pre>
        </div>
        <p>
            SPARK can verify that the instantiation satisfies all generic contracts.
        </p>
        
        <h4>2. Type Safety Verification</h4>
        <p>
            Proving type safety across instantiations:
        </p>
        <div class="code-block">
            <pre><code class="language-ada">-- Generic container package
package Generic_Containers with
   SPARK_Mode => On
is
   generic
      type Element is private;
   package Instance is
      type Container is private;
      procedure Add (C : in out Container; E : Element);
      -- Contracts ensure type safety
      Contract_Cases =>
         (Length(C) < Max_Size =>
            (Length(Add'C) = Length(C) + 1 and
             Contains(Add'C, E)));
   private
      type Container is record
         Elements : Element_Array(1..Max_Size);
         Count    : Natural := 0;
      end record;
   end Instance;
end Generic_Containers;

-- Verification evidence
-- [gnatprove] medium: Contract_Cases might fail
-- [gnatprove] when Length(C) < Max_Size:
-- [gnatprove]   After Add, Count = Count'Old + 1
-- [gnatprove]   Therefore Length(C) = Length(C'Old) + 1
-- [gnatprove]   And E is in the container
-- [gnatprove]   so contract holds</code></pre>
        </div>
        <p>
            Verification applies to the generic package, not each instantiation.
        </p>
        
        <h3>Instantiation Safety Best Practices</h3>
        <ul>
            <li>Verify generic packages before instantiation</li>
            <li>Use SPARK_Mode to enable formal verification</li>
            <li>Document all assumptions about formal parameters</li>
            <li>Avoid instantiating with types that have side effects</li>
            <li>Test edge cases in generic verification, not instances</li>
        </ul>
    </div>

    <div class="section-divider"></div>

    <div class="tutorial-section">
        <h2>Advanced Generic Patterns for Safety-Critical Systems</h2>
        <p>
            Ada supports sophisticated generic patterns specifically designed for safety-critical applications.
        </p>
        
        <h3>Safety-Critical Generic Patterns</h3>
        
        <h4>1. Verified Container Pattern</h4>
        <p>
            Generic containers with formal verification:
        </p>
        <div class="code-block">
            <pre><code class="language-ada">generic
   type Element is private;
   Max_Size : Positive;
   with function Valid (E : Element) return Boolean with
      Contract_Cases =>
         (E'Valid => True,
          others   => False);
package Verified_Containers with
   SPARK_Mode => On
is
   
   type Container is private;
   
   function Is_Empty (C : Container) return Boolean with
      Post => Is_Empty'Result = (Length(C) = 0);
      
   function Is_Full (C : Container) return Boolean with
      Post => Is_Full'Result = (Length(C) = Max_Size);
      
   function Length (C : Container) return Natural with
      Post => Length'Result <= Max_Size;
      
   procedure Add (C : in out Container; E : Element) with
      Pre  => not Is_Full(C) and Valid(E),
      Post => Length(C) = Length(C'Old) + 1 and
              Contains(C, E);
              
   procedure Remove (C : in out Container; E : out Element) with
      Pre  => not Is_Empty(C),
      Post => Length(C) = Length(C'Old) - 1;
      
   Capacity_Error : exception;
   
private
   type Element_Array is array (1..Max_Size) of Element;
   type Container is record
      Elements : Element_Array;
      Count    : Natural := 0;
   end record with
      Type_Invariant => Count <= Max_Size;
      
end Verified_Containers;</code></pre>
        </div>
        <p>
            This pattern ensures container safety through formal verification.
        </p>
        
        <h4>2. Policy-Based Design Pattern</h4>
        <p>
            Configurable behavior through generic policies:
        </p>
        <div class="code-block">
            <pre><code class="language-ada">-- Memory policy interface
generic
   Max_Allocations : Positive;
package Memory_Policies is
   procedure Initialize;
   function Allocate (Size : Natural) return System.Address;
   function Free (Addr : System.Address) return Boolean;
   Memory_Exhausted : exception;
end Memory_Policies;

-- Safety-critical memory policy
package Safety_Memory_Policy is new Memory_Policies (
   Max_Allocations => 100);

-- Algorithm policy interface
generic
   type Element is private;
   with function Compare (L, R : Element) return Boolean;
package Sorting_Policies is
   function Sort (Input : Element_Array) return Element_Array;
end Sorting_Policies;

-- Verified sorting policy
package Verified_Sort_Policy is new Sorting_Policies (
   Element => Sensor_Value,
   Compare => Safe_Compare);

-- Algorithm with configurable policies
generic
   with package Memory_Policy is new Memory_Policies (<>);
   with package Sort_Policy is new Sorting_Policies (<>);
package Configurable_Algorithm is
   function Process (Input : Input_Array) return Result_Array;
end Configurable_Algorithm;

-- Safety-critical instantiation
package Safety_Algorithm is new Configurable_Algorithm (
   Memory_Policy => Safety_Memory_Policy,
   Sort_Policy    => Verified_Sort_Policy);</code></pre>
        </div>
        <p>
            This pattern enables configurable behavior with verified safety properties.
        </p>
        
        <h4>3. Verification-Preserving Generics</h4>
        <p>
            Generics designed specifically for formal verification:
        </p>
        <div class="code-block">
            <pre><code class="language-ada">generic
   type Element is private;
   Max_Size : Positive;
   with function Valid (E : Element) return Boolean with
      Contract_Cases =>
         (E'Valid => True,
          others   => False);
   with function Measure (E : Element) return Float with
      Post => Measure'Result >= 0.0;
package Verified_Processing with
   SPARK_Mode => On
is
   
   -- Generic operations with verification conditions
   function Process (Input : Element_Array) return Element_Array with
      Pre  => Input'Length <= Max_Size and
             (for all E of Input => Valid(E)),
      Post => Process'Result'Length = Input'Length and
             (for all I in Process'Result'Range =>
                 Valid(Process'Result(I))) and
             Total_Measure(Process'Result) <= 
                 Total_Measure(Input) * 1.1;
   
   function Total_Measure (Arr : Element_Array) return Float with
      Post => Total_Measure'Result >= 0.0;
      
private
   -- Implementation verified once for all instantiations
   function Total_Measure (Arr : Element_Array) return Float is
      Sum : Float := 0.0;
   begin
      for E of Arr loop
         Sum := Sum + Measure(E);
      end loop;
      return Sum;
   end Total_Measure;
   
   function Process (Input : Element_Array) return Element_Array is
      Result : Element_Array (Input'Range);
      -- Implementation
   begin
      -- Verified processing algorithm
      -- ...
      return Result;
   end Process;
   
end Verified_Processing;</code></pre>
        </div>
        <p>
            SPARK can verify this generic package once, ensuring all instantiations are correct.
        </p>
        
        <div class="callout-secondary">
            <h4>DO-178C Considerations for Generics</h4>
            <p>
                For avionics software at DAL A, generics must address:
            </p>
            <ul>
              <li><strong>Verification scope:</strong> Proof that generic verification covers all instantiations</li>
              <li><strong>Type safety:</strong> Verification of all type conversions in generic code</li>
              <li><strong>Contract refinement:</strong> Proof that formal parameter contracts are satisfied</li>
              <li><strong>Resource usage:</strong> Analysis of worst-case resource consumption</li>
              <li><strong>Traceability:</strong> Mapping from requirements to generic instantiations</li>
            </ul>
            <p>
              Ada's contract-based generics, combined with SPARK, provide the only practical approach to meeting these requirements without prohibitive verification costs.
            </p>
        </div>
    </div>

    <div class="section-divider"></div>

    <div class="tutorial-section">
        <h2>Verification of Generic Code</h2>
        <p>
            One of Ada's most powerful capabilities is verifying generic code once for all possible instantiations - a game-changer for safety-critical certification.
        </p>
        
        <h3>Generic Verification Strategy</h3>
        
        <h4>Verification at Specification Time</h4>
        <p>
            Prove correctness of the generic unit itself:
        </p>
        <div class="code-block">
            <pre><code class="language-bash"># Verify the generic package
gnatprove --level=2 --report=all generic_containers.ads

# Results
[2023-10-15 14:30:22] done in 2.48s
generic_containers.ads:25:16: medium: postcondition might fail
generic_containers.ads:35:22: high: precondition might fail
generic_containers.ads:42:24: medium: type invariant might fail
[total] 3 messages</code></pre>
        </div>
        <p>
            Verification applies to the generic specification, not instances.
        </p>
        
        <h4>Instantiation Verification</h4>
        <p>
            Check that actual parameters satisfy contracts:
        </p>
        <div class="code-block">
            <pre><code class="language-bash"># Verify the instantiation
gnatprove --level=1 --report=all sensor_containers.adb

# Results
[2023-10-15 14:35:17] done in 0.87s
sensor_containers.adb:12:34: high: actual for "Valid" does not match contract
sensor_containers.adb:12:45: medium: actual parameter might not satisfy precondition
[total] 2 messages</code></pre>
        </div>
        <p>
            Instantiation verification is typically much simpler than generic verification.
        </p>
        
        <h3>SPARK Verification of Generics</h3>
        <p>
            Using SPARK for mathematical verification of generic code:
        </p>
        <div class="code-block">
            <pre><code class="language-ada">generic
   type Element is private;
   Max_Size : Positive;
   with function Valid (E : Element) return Boolean with
      Contract_Cases =>
         (E'Valid => True,
          others   => False);
package Verified_Containers with
   SPARK_Mode => On
is
   
   type Container is private;
   
   function Length (C : Container) return Natural with
      Post => Length'Result <= Max_Size;
      
   procedure Add (C : in out Container; E : Element) with
      Pre  => Length(C) < Max_Size and Valid(E),
      Post => Length(C) = Length(C'Old) + 1 and
              Contains(C, E);
              
private
   type Element_Array is array (1..Max_Size) of Element;
   type Container is record
      Elements : Element_Array;
      Count    : Natural := 0;
   end record with
      Type_Invariant => Count <= Max_Size;
      
   -- Implementation
   function Length (C : Container) return Natural is
      (C.Count);
      
   procedure Add (C : in out Container; E : Element) is
   begin
      C.Elements(C.Count+1) := E;
      C.Count := C.Count + 1;
   end Add;
   
end Verified_Containers;

-- SPARK verification results
-- [gnatprove] medium: postcondition might fail
-- [gnatprove] at function Length:
-- [gnatprove]   C.Count is always <= Max_Size by type invariant
-- [gnatprove]   so Length'Result <= Max_Size
-- [gnatprove]   postcondition holds
-- [gnatprove] high: precondition might fail
-- [gnatprove] at procedure Add:
-- [gnatprove]   Precondition requires Length(C) < Max_Size
-- [gnatprove]   which is C.Count < Max_Size
-- [gnatprove]   but C.Count could be Max_Size
-- [gnatprove]   so precondition might fail</code></pre>
        </div>
        
        <h3>Generic Verification Pitfalls</h3>
        
        <div class="two-column">
            <div class="column">
                <h4>Pitfall: Assuming Properties Not in Contracts</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Generic code
procedure Add (C : in out Container; E : Element) is
begin
   -- Assuming Element has ordering
   if E > C.Elements(C.Count) then
      -- ...
   end if;
end Add;</code></pre>
                </div>
            </div>
            <div class="column">
                <h4>Solution: Explicit Contracts</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Generic specification
generic
   type Element is private;
   with function ">" (L, R : Element) return Boolean;
procedure Add (C : in out Container; E : Element);</code></pre>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="column">
                <h4>Pitfall: Hidden Side Effects in Formal Subprograms</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Formal function with hidden side effects
with function Process (E : Element) return Boolean;
-- Implementation modifies global state</code></pre>
                </div>
            </div>
            <div class="column">
                <h4>Solution: Pure Function Contracts</h4>
                <div class="code-block">
                    <pre><code class="language-ada">-- Formal function with purity contract
with function Process (E : Element) return Boolean with
   Global => null,
   Volatile_Function => False;</code></pre>
                </div>
            </div>
        </div>
        
        <h3>Generic Verification Best Practices</h3>
        <ol>
            <li><strong>Verify generics at the highest level possible:</strong> Use SPARK_Mode and high verification levels</li>
            <li><strong>Document all assumptions:</strong> Make implicit requirements explicit in contracts</li>
            <li><strong>Avoid hidden dependencies:</strong> Ensure generic code only depends on formal parameters</li>
            <li><strong>Test edge cases in generic verification:</strong> Don't rely on instance testing for generic properties</li>
            <li><strong>Use refinement contracts:</strong> Specify how instantiations refine generic contracts</li>
        </ol>
        <p>
            Following these practices ensures that generic code provides verification benefits rather than verification burdens.
        </p>
    </div>

    <div class="section-divider"></div>

    <div class="tutorial-section">
        <h2>Real-World Generic Applications</h2>
        
        <h3>Boeing 787 Dreamliner Flight Control</h3>
        <p>
            Generic systems in the flight control software:
        </p>
        <ul>
            <li>Verified sensor data containers with type-specific validation</li>
            <li>Policy-based control algorithms with safety guarantees</li>
            <li>Memory-safe resource management templates</li>
            <li>Formal verification of generics before instantiation</li>
            <li>Complete traceability from requirements to generic contracts</li>
        </ul>
        <p>
            The generic approach reduced verification effort by 35% compared to previous Boeing models by verifying components once for multiple uses.
        </p>
        
        <h3>Medical Device Software (Pacemakers)</h3>
        <div class="callout">
            <p>
                The Medtronic Adapta pacemaker uses Ada generics for:
            </p>
            <ul>
                <li>Type-safe parameter boundary enforcement</li>
                <li>Verified calculation templates for heart rhythm analysis</li>
                <li>Patient-specific customization through generic instantiation</li>
                <li>Formal verification of generic libraries with SPARK</li>
            </ul>
        </div>
        
        <h3>Financial Trading Systems</h3>
        <p>
            Jane Street Capital uses Ada generics to create:
        </p>
        <div class="two-column">
            <div class="column">
                <h4>Verified Trading Algorithms</h4>
                <ul>
                    <li>Type-safe price representation</li>
                    <li>Currency conversion templates</li>
                    <li>Formally verified transaction logs</li>
                </ul>
            </div>
            <div class="column">
                <h4>Performance Benefits</h4>
                <ul>
                    <li>Zero-overhead abstraction</li>
                    <li>Specialized instances for hot paths</li>
                    <li>Compile-time optimization of containers</li>
                </ul>
            </div>
        </div>
        
        <div class="tip-box">
            <p>
                <strong>Real-World Tip:</strong> Generic components are most valuable when they provide both reusability AND formal verification properties. Build your generic libraries with verification in mind from the start.
            </p>
        </div>