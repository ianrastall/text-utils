<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Utilities</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0V2F0V7FWB"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'G-0V2F0V7FWB');
	</script>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/custom.css">
</head>
<body>
    <!-- Header Placeholder -->
    <div id="header-placeholder"></div>

    <!-- Main Content -->
    <div class="container-fluid my-4">
        <div class="row gx-3 gy-3">
            <main class="col-md-9">
                <div class="card bg-dark border-secondary">
                    <div class="card-body">
                        <!-- Dynamic Title -->
                        <h2 class="card-title mb-4 d-flex align-items-center" id="dynamic-title">
                            <span class="material-icons me-3" style="font-size: 36px;" aria-hidden="true" id="tool-icon">lock</span>
                            <span id="tool-name">Hashing Tool</span>
                        </h2>

                        <p class="text-white-50 mb-4" id="tool-description">Hash, encode, and decode text using various algorithms and formats.</p>

                        <div class="post-content">
                            <div class="mb-3">
                                <label for="textInput" class="form-label">Input / Output</label>
                                <textarea id="textInput" class="form-control font-monospace" rows="8" placeholder="Enter text hereâ€¦"></textarea>
                            </div>

                            <div class="row g-3 mb-3">
                                <div class="col-md-6">
                                    <label for="operationType" class="form-label">Operation</label>
                                    <select id="operationType" class="form-select">
                                        <option value="encode">Encode / Hash</option>
                                        <option value="decode">Decode</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label for="algorithmSelect" class="form-label">Algorithm</label>
                                    <select id="algorithmSelect" class="form-select">
                                        <optgroup label="Common Encodings">
                                            <option value="base64">Base64</option>
                                            <option value="base64url">Base64-URL</option>
                                            <option value="base32">Base32</option>
                                            <option value="url">URL Encoding</option>
                                            <option value="hex">Hexadecimal</option>
                                            <option value="html">HTML Entities</option>
                                        </optgroup>
                                        <optgroup label="Hashing (Encode Only)">
                                            <option value="md5">MD5</option>
                                            <option value="sha1">SHA-1</option>
                                            <option value="sha256">SHA-256</option>
                                            <option value="sha384">SHA-384</option>
                                            <option value="sha512">SHA-512</option>
                                            <option value="crc32">CRC-32</option>
                                        </optgroup>
                                        <optgroup label="Other">
                                            <option value="rot13">ROT13</option>
                                            <option value="rot47">ROT47</option>
                                            <option value="binary">Binary</option>
                                            <option value="reverse">Reverse Text</option>
                                        </optgroup>
                                    </select>
                                </div>
                            </div>
                            <div class="d-flex gap-2 flex-wrap">
                                <button type="button" id="transformBtn" class="btn btn-task d-flex align-items-center">
                                    <span class="material-icons me-2" aria-hidden="true">sync_alt</span> Transform
                                </button>
                                <button type="button" id="copyBtn" class="btn btn-edit d-flex align-items-center">
                                    <span class="material-icons me-2" aria-hidden="true">content_copy</span> Copy Result
                                </button>
                                <button type="button" id="clearBtn" class="btn btn-clear d-flex align-items-center">
                                    <span class="material-icons me-2" aria-hidden="true">clear</span> Clear
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </main>

            <aside class="col-md-3">
                <div class="card bg-dark border-secondary">
                    <div class="card-body p-0">
                        <nav class="sidebar nav flex-column" id="dynamic-sidebar">
                            <!-- Sidebar will be injected here by JavaScript -->
                        </nav>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <!-- Footer Placeholder -->
    <div id="footer-placeholder"></div>
    
    <script src="js/bootstrap.bundle.min.js"></script>
    <script src="js/component-loader.js"></script>

    <script>
        // --- Initialize Theme Switcher ---
        function initThemeSwitcher() {
            const themes = ['burlywood', 'cadetblue', 'cornflowerblue', 'dodgerblue', 'lightcoral', 'lightgreen', 'plum', 'thistle', 'tomato', 'violet'];
            const themeDropdown = document.getElementById('accentColorDropdownMenu');
            const htmlElement = document.documentElement;

            function applyTheme(theme) {
                htmlElement.className = ''; // Remove all existing classes
                htmlElement.classList.add('theme-' + theme);
                localStorage.setItem('accentTheme', theme);
            }

            // Populate the dropdown menu with theme options
            if (themeDropdown) {
                themes.forEach(theme => {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.className = 'dropdown-item';
                    button.type = 'button';
                    button.textContent = theme;
                    button.onclick = () => applyTheme(theme);
                    li.appendChild(button);
                    themeDropdown.appendChild(li);
                });
            }

            // Set the initial theme on page load
            const savedTheme = localStorage.getItem('accentTheme') || 'burlywood';
            applyTheme(savedTheme);
        }

        // --- Initialize Page Metadata ---
        async function initPageMetadata() {
            const currentSlug = 'hashing-tool'; // Hardcoded for this specific page

            try {
                const response = await fetch('config/tools.json');
                if (!response.ok) throw new Error('Failed to load tools.json');
                const tools = await response.json();

                const currentTool = tools.find(tool => tool.slug === currentSlug) || {};

                // Set page title and description
                document.getElementById('tool-name').textContent = currentTool.name || 'Hashing Tool';
                document.getElementById('tool-description').textContent = currentTool.description || 'Hash, encode, and decode text using various algorithms and formats.';

                // Set icon
                const iconEl = document.getElementById('tool-icon');
                if (currentTool.icon) {
                    if (currentTool.icon.endsWith('.svg') || currentTool.icon.endsWith('.png')) {
                        iconEl.outerHTML = `<img src="${currentTool.icon}" alt="" style="height: 36px; margin-right: 15px;" id="tool-icon" aria-hidden="true" />`;
                    } else {
                        // Material Icon - already set in HTML
                        iconEl.textContent = currentTool.icon;
                    }
                }

                // Generate sidebar, marking current page as active
                const sidebarHtml = tools
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .map(tool => {
                        const isActive = tool.slug === currentSlug;
                        const activeClass = isActive ? ' active' : '';
                        const iconHtml = tool.icon ?
                            (tool.icon.endsWith('.svg') || tool.icon.endsWith('.png') ?
                                `<img src="${tool.icon}" alt="" class="icon me-2" aria-hidden="true" />` :
                                `<span class="material-icons me-2" aria-hidden="true">${tool.icon}</span>`) :
                            `<span class="me-2" style="width: 24px;"></span>`;

                        return `
                            <a class="nav-link d-flex align-items-center${activeClass}" href="${tool.slug}.html">
                                ${iconHtml}
                                <span>${tool.name}</span>
                            </a>
                        `;
                    }).join('');

                document.getElementById('dynamic-sidebar').innerHTML = sidebarHtml;

            } catch (error) {
                console.error('Error initializing page meta', error);
            }
        }

        // --- Hashing Tool Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            'use strict';
            const textArea = document.getElementById('textInput');
            const operationType = document.getElementById('operationType');
            const algorithmSelect = document.getElementById('algorithmSelect');
            const transformBtn = document.getElementById('transformBtn');
            const copyBtn = document.getElementById('copyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const HASH_ALGORITHMS = ['md5', 'sha1', 'sha256', 'sha384', 'sha512', 'crc32'];

            // --- Modern, UTF-8 Safe Base64/Base64-URL ---
            const encodeBase64 = (text, isUrlSafe = false) => {
                const bytes = new TextEncoder().encode(text);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                let base64 = btoa(binary);
                if (isUrlSafe) {
                    base64 = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                }
                return base64;
            };

            const decodeBase64 = (text, isUrlSafe = false) => {
                if (isUrlSafe) {
                    text = text.replace(/-/g, '+').replace(/_/g, '/');
                    while (text.length % 4) text += '=';
                }
                const binaryString = atob(text);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder().decode(bytes);
            };

            // --- Base32 Implementation ---
            const base32Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            
            const encodeBase32 = (text) => {
                const bytes = new TextEncoder().encode(text);
                let result = '';
                let buffer = 0;
                let bitsLeft = 0;
                
                for (let i = 0; i < bytes.length; i++) {
                    buffer = (buffer << 8) | bytes[i];
                    bitsLeft += 8;
                    
                    while (bitsLeft >= 5) {
                        result += base32Alphabet[(buffer >> (bitsLeft - 5)) & 31];
                        bitsLeft -= 5;
                    }
                }
                
                if (bitsLeft > 0) {
                    result += base32Alphabet[(buffer << (5 - bitsLeft)) & 31];
                }
                
                // Add padding
                while (result.length % 8 !== 0) {
                    result += '=';
                }
                
                return result;
            };

            const decodeBase32 = (text) => {
                text = text.replace(/=+$/, '').toUpperCase();
                const bytes = [];
                let buffer = 0;
                let bitsLeft = 0;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const value = base32Alphabet.indexOf(char);
                    if (value === -1) throw new Error('Invalid Base32 character: ' + char);
                    
                    buffer = (buffer << 5) | value;
                    bitsLeft += 5;
                    
                    if (bitsLeft >= 8) {
                        bytes.push((buffer >> (bitsLeft - 8)) & 255);
                        bitsLeft -= 8;
                    }
                }
                
                return new TextDecoder().decode(new Uint8Array(bytes));
            };

            // --- Other Helpers ---
            const rot47 = (str) => str.replace(/[\x21-\x7E]/g, c => String.fromCharCode(33 + ((c.charCodeAt(0) + 14) % 94)));

            // --- MD5 Implementation ---
            const md5 = (str) => {
                const md5cycle = (x, k) => {
                    let a = x[0], b = x[1], c = x[2], d = x[3];
                    
                    a = ff(a, b, c, d, k[0], 7, -680876936);
                    d = ff(d, a, b, c, k[1], 12, -389564586);
                    c = ff(c, d, a, b, k[2], 17, 606105819);
                    b = ff(b, c, d, a, k[3], 22, -1044525330);
                    a = ff(a, b, c, d, k[4], 7, -176418897);
                    d = ff(d, a, b, c, k[5], 12, 1200080426);
                    c = ff(c, d, a, b, k[6], 17, -1473231341);
                    b = ff(b, c, d, a, k[7], 22, -45705983);
                    a = ff(a, b, c, d, k[8], 7, 1770035416);
                    d = ff(d, a, b, c, k[9], 12, -1958414417);
                    c = ff(c, d, a, b, k[10], 17, -42063);
                    b = ff(b, c, d, a, k[11], 22, -1990404162);
                    a = ff(a, b, c, d, k[12], 7, 1804603682);
                    d = ff(d, a, b, c, k[13], 12, -40341101);
                    c = ff(c, d, a, b, k[14], 17, -1502002290);
                    b = ff(b, c, d, a, k[15], 22, 1236535329);
                    
                    a = gg(a, b, c, d, k[1], 5, -165796510);
                    d = gg(d, a, b, c, k[6], 9, -1069501632);
                    c = gg(c, d, a, b, k[11], 14, 643717713);
                    b = gg(b, c, d, a, k[0], 20, -373897302);
                    a = gg(a, b, c, d, k[5], 5, -701558691);
                    d = gg(d, a, b, c, k[10], 9, 38016083);
                    c = gg(c, d, a, b, k[15], 14, -660478335);
                    b = gg(b, c, d, a, k[4], 20, -405537848);
                    a = gg(a, b, c, d, k[9], 5, 568446438);
                    d = gg(d, a, b, c, k[14], 9, -1019803690);
                    c = gg(c, d, a, b, k[3], 14, -187363961);
                    b = gg(b, c, d, a, k[8], 20, 1163531501);
                    a = gg(a, b, c, d, k[13], 5, -1444681467);
                    d = gg(d, a, b, c, k[2], 9, -51403784);
                    c = gg(c, d, a, b, k[7], 14, 1735328473);
                    b = gg(b, c, d, a, k[12], 20, -1926607734);
                    
                    a = hh(a, b, c, d, k[5], 4, -378558);
                    d = hh(d, a, b, c, k[8], 11, -2022574463);
                    c = hh(c, d, a, b, k[11], 16, 1839030562);
                    b = hh(b, c, d, a, k[14], 23, -35309556);
                    a = hh(a, b, c, d, k[1], 4, -1530992060);
                    d = hh(d, a, b, c, k[4], 11, 1272893353);
                    c = hh(c, d, a, b, k[7], 16, -155497632);
                    b = hh(b, c, d, a, k[10], 23, -1094730640);
                    a = hh(a, b, c, d, k[13], 4, 681279174);
                    d = hh(d, a, b, c, k[0], 11, -358537222);
                    c = hh(c, d, a, b, k[3], 16, -722521979);
                    b = hh(b, c, d, a, k[6], 23, 76029189);
                    a = hh(a, b, c, d, k[9], 4, -640364487);
                    d = hh(d, a, b, c, k[12], 11, -421815835);
                    c = hh(c, d, a, b, k[15], 16, 530742520);
                    b = hh(b, c, d, a, k[2], 23, -995338651);
                    
                    a = ii(a, b, c, d, k[0], 6, -198630844);
                    d = ii(d, a, b, c, k[7], 10, 1126891415);
                    c = ii(c, d, a, b, k[14], 15, -1416354905);
                    b = ii(b, c, d, a, k[5], 21, -57434055);
                    a = ii(a, b, c, d, k[12], 6, 1700485571);
                    d = ii(d, a, b, c, k[3], 10, -1894986606);
                    c = ii(c, d, a, b, k[10], 15, -1051523);
                    b = ii(b, c, d, a, k[1], 21, -2054922799);
                    a = ii(a, b, c, d, k[8], 6, 1873313359);
                    d = ii(d, a, b, c, k[15], 10, -30611744);
                    c = ii(c, d, a, b, k[6], 15, -1560198380);
                    b = ii(b, c, d, a, k[13], 21, 1309151649);
                    a = ii(a, b, c, d, k[4], 6, -145523070);
                    d = ii(d, a, b, c, k[11], 10, -1120210379);
                    c = ii(c, d, a, b, k[2], 15, 718787259);
                    b = ii(b, c, d, a, k[9], 21, -343485551);
                    
                    x[0] = add32(a, x[0]);
                    x[1] = add32(b, x[1]);
                    x[2] = add32(c, x[2]);
                    x[3] = add32(d, x[3]);
                };
                
                const cmn = (q, a, b, x, s, t) => {
                    a = add32(add32(a, q), add32(x, t));
                    return add32((a << s) | (a >>> (32 - s)), b);
                };
                const ff = (a, b, c, d, x, s, t) => cmn((b & c) | ((~b) & d), a, b, x, s, t);
                const gg = (a, b, c, d, x, s, t) => cmn((b & d) | (c & (~d)), a, b, x, s, t);
                const hh = (a, b, c, d, x, s, t) => cmn(b ^ c ^ d, a, b, x, s, t);
                const ii = (a, b, c, d, x, s, t) => cmn(c ^ (b | (~d)), a, b, x, s, t);
                
                const md51 = (s) => {
                    const n = s.length;
                    const state = [1732584193, -271733879, -1732584194, 271733878];
                    let i;
                    for (i = 64; i <= s.length; i += 64) {
                        md5cycle(state, md5blk(s.substring(i - 64, i)));
                    }
                    s = s.substring(i - 64);
                    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    for (i = 0; i < s.length; i++)
                        tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                    tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                    if (i > 55) {
                        md5cycle(state, tail);
                        for (i = 0; i < 16; i++) tail[i] = 0;
                    }
                    tail[14] = n * 8;
                    md5cycle(state, tail);
                    return state;
                };
                
                const md5blk = (s) => {
                    const md5blks = [];
                    for (let i = 0; i < 64; i += 4) {
                        md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                    }
                    return md5blks;
                };
                
                const rhex = (n) => {
                    let s = '';
                    for (let j = 0; j < 4; j++)
                        s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
                    return s;
                };
                
                const hex_chr = '0123456789abcdef'.split('');
                
                const add32 = (a, b) => (a + b) & 0xFFFFFFFF;
                
                // Convert string to UTF-8 bytes
                const utf8Encode = (str) => {
                    let utf8 = '';
                    for (let i = 0; i < str.length; i++) {
                        let charcode = str.charCodeAt(i);
                        if (charcode < 0x80) utf8 += String.fromCharCode(charcode);
                        else if (charcode < 0x800) {
                            utf8 += String.fromCharCode(0xc0 | (charcode >> 6));
                            utf8 += String.fromCharCode(0x80 | (charcode & 0x3f));
                        }
                        else if (charcode < 0xd800 || charcode >= 0xe000) {
                            utf8 += String.fromCharCode(0xe0 | (charcode >> 12));
                            utf8 += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3f));
                            utf8 += String.fromCharCode(0x80 | (charcode & 0x3f));
                        }
                        else {
                            i++;
                            charcode = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                            utf8 += String.fromCharCode(0xf0 | (charcode >> 18));
                            utf8 += String.fromCharCode(0x80 | ((charcode >> 12) & 0x3f));
                            utf8 += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3f));
                            utf8 += String.fromCharCode(0x80 | (charcode & 0x3f));
                        }
                    }
                    return utf8;
                };
                
                return md51(utf8Encode(str)).map(rhex).join('');
            };

            // --- CRC32 Implementation ---
            const crc32 = (str) => {
                const table = [];
                let c;
                for (let n = 0; n < 256; n++) {
                    c = n;
                    for (let k = 0; k < 8; k++) {
                        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                    }
                    table[n] = c;
                }
                
                let crc = 0 ^ (-1);
                const bytes = new TextEncoder().encode(str);
                for (let i = 0; i < bytes.length; i++) {
                    crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
                }
                return ((crc ^ (-1)) >>> 0).toString(16).padStart(8, '0');
            };

            // --- Transformation Engine ---
            const transformText = async () => {
                const text = textArea.value;
                if (!text) { showToast('Please enter some text to transform.', 'warning'); return; }

                const operation = operationType.value;
                const algorithm = algorithmSelect.value;

                try {
                    let result = '';
                    const isEncode = operation === 'encode';

                    if (!isEncode && HASH_ALGORITHMS.includes(algorithm)) {
                        showToast('Hashing algorithms cannot be decoded.', 'warning');
                        return;
                    }

                    // --- Encoding / Hashing ---
                    if (isEncode) {
                        switch (algorithm) {
                            case 'base64': result = encodeBase64(text); break;
                            case 'base64url': result = encodeBase64(text, true); break;
                            case 'base32': result = encodeBase32(text); break;
                            case 'url': result = encodeURIComponent(text); break;
                            case 'hex': result = [...new TextEncoder().encode(text)].map(b => b.toString(16).padStart(2, '0')).join(''); break;
                            case 'html': result = text.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]); break;
                            case 'rot13': result = text.replace(/[a-zA-Z]/g, c => String.fromCharCode((c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26)); break;
                            case 'rot47': result = rot47(text); break;
                            case 'binary': result = [...new TextEncoder().encode(text)].map(b => b.toString(2).padStart(8, '0')).join(' '); break;
                            case 'reverse': result = [...text].reverse().join(''); break;
                            default: result = await hashText(text, algorithm); break; // Handles all hashes
                        }
                    } 
                    // --- Decoding ---
                    else {
                        switch (algorithm) {
                            case 'base64': result = decodeBase64(text); break;
                            case 'base64url': result = decodeBase64(text, true); break;
                            case 'base32': result = decodeBase32(text); break;
                            case 'url': result = decodeURIComponent(text); break;
                            case 'hex':
                                const hex = text.replace(/[^0-9a-fA-F]/g, '');
                                if (hex.length % 2 !== 0) throw new Error('Invalid hex string length');
                                const bytes = new Uint8Array(hex.match(/../g).map(h => parseInt(h, 16)));
                                result = new TextDecoder().decode(bytes);
                                break;
                            case 'html':
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(text, 'text/html');
                                result = doc.documentElement.textContent;
                                break;
                            case 'rot13': result = text.replace(/[a-zA-Z]/g, c => String.fromCharCode((c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26)); break;
                            case 'rot47': result = rot47(text); break;
                            case 'binary':
                                const binaryCleaned = text.replace(/\s+/g, '');
                                if (/[^01]/.test(binaryCleaned) || binaryCleaned.length % 8 !== 0) throw new Error('Invalid binary string');
                                const binaryBytes = new Uint8Array(binaryCleaned.match(/.{1,8}/g).map(bin => parseInt(bin, 2)));
                                result = new TextDecoder().decode(binaryBytes);
                                break;
                            case 'reverse': result = [...text].reverse().join(''); break;
                            default: throw new Error(`Decoding not supported for ${algorithm}`);
                        }
                    }
                    textArea.value = result;
                    showToast(`Success: ${operation}d with ${algorithm}.`, 'success');
                } catch (error) {
                    console.error('Transformation error:', error);
                    showToast(`Error during ${operation}: ${error.message}`, 'danger');
                }
            };

            // --- Hashing Logic ---
            async function hashText(text, algorithm) {
                const algoUpper = algorithm.toUpperCase();
                if (algoUpper === 'MD5') return md5(text);
                if (algoUpper === 'CRC32') return crc32(text);

                const algoMap = {'SHA1':'SHA-1', 'SHA256':'SHA-256', 'SHA384':'SHA-384', 'SHA512':'SHA-512'};
                if (!algoMap[algoUpper]) throw new Error('Unsupported hash algorithm');

                const data = new TextEncoder().encode(text);
                const hashBuffer = await crypto.subtle.digest(algoMap[algoUpper], data);
                return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
            }

            // --- UI Event Listeners ---
            transformBtn.addEventListener('click', transformText);
            textArea.addEventListener('keydown', e => { if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); transformText(); } });
            copyBtn.addEventListener('click', () => navigator.clipboard.writeText(textArea.value).then(() => showToast('Result copied!', 'success'), () => showToast('Copy failed.', 'danger')));
            clearBtn.addEventListener('click', () => { textArea.value = ''; showToast('Cleared.', 'info'); });
            
            const safeguardOperation = () => {
                if (HASH_ALGORITHMS.includes(algorithmSelect.value) && operationType.value === 'decode') {
                    operationType.value = 'encode';
                    showToast('Hashing algorithms only support encoding.', 'info');
                }
            };
            algorithmSelect.addEventListener('change', safeguardOperation);
            operationType.addEventListener('change', safeguardOperation);

            // --- Secure Toast Notification ---
            function showToast(message, variant = 'info') {
                let container = document.querySelector('.toast-container');
                if (!container) {
                    container = document.createElement('div');
                    container.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                    container.style.zIndex = '1100';
                    document.body.appendChild(container);
                }
                const toastEl = document.createElement('div');
                toastEl.className = `toast align-items-center text-bg-${variant} border-0`;
                toastEl.setAttribute('role', 'alert');
                toastEl.setAttribute('aria-live', 'polite');
                toastEl.setAttribute('aria-atomic', 'true');
                const dFlex = document.createElement('div');
                dFlex.className = 'd-flex';
                const toastBody = document.createElement('div');
                toastBody.className = 'toast-body';
                toastBody.textContent = message; // SECURITY: Use textContent to prevent XSS
                const closeBtn = document.createElement('button');
                closeBtn.type = 'button';
                closeBtn.className = 'btn-close btn-close-white me-2 m-auto';
                closeBtn.setAttribute('data-bs-dismiss', 'toast');
                closeBtn.setAttribute('aria-label', 'Close');
                dFlex.appendChild(toastBody);
                dFlex.appendChild(closeBtn);
                toastEl.appendChild(dFlex);
                container.appendChild(toastEl);
                const toast = new bootstrap.Toast(toastEl, { delay: 3000 });
                toast.show();
                toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
            }
        });

        // --- Initialize Everything ---
        document.addEventListener('DOMContentLoaded', async function () {
            // Load header and footer components first
            await ComponentLoader.loadAll();
            
            // Initialize theme switcher after header is loaded
            initThemeSwitcher();
            
            // Initialize page metadata
            await initPageMetadata();
        });
    </script>
</body>
</html>
